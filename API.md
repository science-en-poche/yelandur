Yelandur API
============

Current version of the API is `1`.

Yelandur serves its API from `domain.com/vX` where `X` is the current
API version. Anything above that (e.g. `domain.com/`) returns a `404`
error. Therefore you must prepend `/vX` to all your API calls. This
will be shown in the first few examples below.


Version 1
---------

The API uses JSON as base format, and tries to follow the guidelines set
down by the [Ember.js REST
Adapter](http://emberjs.com/guides/models/the-rest-adapter/), i.e.:

* A dedicated top-level endpoint for each resource
* All data is encapsulated in a root object
* Any relationships to other objects are reflected as references to the
  `id`s of the linked objects
* Some resources can be transferred (in one direction or the other)
  individually or in arrays (always encapsulated in their root), and
  eventually it will be possible to sideload linked objects (but only in
  the server -> client direction)

All this should become clearer in the examples below.


### Auth

All requests that modify data (`POST`, `PUT`, `DELETE`) require
authentication. All requests that involve experiment results or somehow
private data also require authentication.

For now only users can be authenticated (that is, researchers accessing
data generated by their experiments), but authenticating devices is in
the works (so that device users can retrieve their previously uploaded
results).

Authentication is done thanks to [BrowserID /
Persona](https://login.persona.org/). The callback given to the
BrowserID protocol is `/auth/browserid/login` (i.e.
`/v1/auth/browserid/login`); if authentication is successful, a session
cookie is set.

When testing manually, you can authenticate using
[Naja](https://github.com/wehlutyk/naja) (the Ajax frontend) and then
make your API requests directly in-browser.

`GET /auth/browserid/logout` (so `/v1/auth/browserid/logout` really)
clears the session cookie, i.e. logs the user out.


### Users

Users are identified by their login name, i.e. `user_id`. Being
authenticated will give you access to requests that modify data, and
show you additional private data in results.

A fully shown user has the following properties:

* `user_id` (public)
* `user_id_is_set` (public)
* `gravatar_id` (public)
* `persona_email` (private)

The `user_id` will be the user's login name, and is unique across all
users. The `persona_email` will be the user's personal email adress
(also unique), obtained through BrowserID / Persona.  The `gravatar_id`
is the md5 hexadecimal hash of the `personal_email` (as described in the
[Gravatar documentation](http://en.gravatar.com/site/implement/hash/)).

#### `/users/<user_id>`

##### `GET`

`GET /users/<user_id>` (so `/v1/users/<user_id>`) gets public
information about the user identified by `user_id`. If you are
authenticated as being that user, private information (e.g. email
address) is included.

So `GET /users/jane` returns

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf"
    }
}
```

if you're not authenticated or if you're authenticated as someone else
than `jane` (note the root object encapsulation, mentioned in the
guidelines above).

If you're authenticated as `jane`, you'll get additional private
information (here, only the email attached to the user's Persona (i.e.
BrowserID)):

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

Any `GET` on a non-existing user (or deleted or disabled, if those are
implemented further down the road) will return an error with a `404`
status code:

```json
{
    "error": {
        "exception": "DoesNotExist",
        "exception_message": "User matching query does not exist.",
        "explanation": "The requested user was not found"
    }
}
```

##### `PUT`

A `PUT` operation requires to be authenticated as the user you will be
modifying. `PUT`ing a user with new information will modify that user's
data. Currently the only allowed operation is to set the user's
`user_id`, and it can only be done once. The reason is that new users
are created only through Persona / BrowserID: when a unknown user logs
in with Persona, the server receives his associated email address, and
sets the `user_id` of the newly created user to be that email address.
Querying such a user with `GET /users/bill@example.com` will yield:

```json
{
    "user": {
        "user_id": "bill@example.com",
        "user_id_is_set": "false",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

(Note the `"user_id_is_set": "false"` field.)

It is then necessary to set the user's `user_id` (to prevent other users
from easily obtaining his email address) with a `PUT
/users/bill@example.com` with the following data:

```json
{
    "user": {
        "user_id": "bill-the-researcher"
    }
}
```

Any other data included will be ignored. Possible errors (always
accompanied by explanations) are, in the following order:

* `404` if the URL-provided `user_id` does not exist (before any other
  error)
* `400` if the received data is malformed (e.g. does not have the root
  `user` object, or is bad JSON)
* `401` if there is no authentication
* `403` if you are authenticated as another user than the one your are
  `PUT`ing to, or if the `user_id` has already been set (i.e. if
  `user_id_is_set` is `true`)
* `400` again if the JSON `user_id` does not fulfil the required syntax
* `409` if the JSON `user_id` is already taken by another user

If the update is successful, the updated user is returned with a `200`
code:

```json
{
    "user": {
        "user_id": "bill-the-researcher",
        "user_id_is_set": "true",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

This operation can only be done once because the user's `user_id` is his
unique identifier on the server, which is not allowed to change once he
has started creating resources. Other operations led by a user will be
refused if his `user_id` has not been set.

##### `DELETE`

Not implemented yet. This needs to decide what different types of
deletion we provide.

#### `/users/me`

##### `GET`

This operation requires authentication, and is used to find out which
user a client is logged in as. If you are logged in as `jane`, `GET
/users/me` will return the same as `GET /users/jane`:

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

If you are not logged in, a `401` error is returned.

#### `/users`

##### `GET`

`GET /users` returns the array of all users with only public data (even
for the one you are logged in as). So being logged in as `jane` would
still yield:

```json
{
    "users": [
        {
            "user_id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf"
        },
        {
            "user_id": "bill-the-researcher",
            "user_id_is_set": "true",
            "gravatar_id": "f5cabff22532bd0025118905bdea50da"
        },
        ...
    ]
}
```

Django-style arguments can be added. So `GET
/users?user_id__startswith=ja` would return users `jane` and `jack`.
Query arguments are only allowed on public fields, and a `403` will be
returned when trying to query using other fields. A `400` error will be
returned when trying to query using non-existing fields. If no user
matching the query is found, an empty array is returned (instead of a
`404`).


### Exps

A fully shown experiment has the following fields:

* `exp_id` (public)
* `name` (public)
* `description` (public)
* `owner_id` (public) [queryable: `owner`]
* `collaborator_ids` (public) [queryable: `collaborators`]
* `n_results` (public)
* `n_profiles` (public)

The `exp_id` is the SHA-256 hexadecimal hash of the string obtained by
putting the `owner_id` and the `name` together, separated by a `/`. In
python:

```python
from hashlib import sha256
print sha256(owner_id + '/' + name).hexdigest()
```

This id is unique across all experiments of all users, which means the
experiment's `name` is unique across all experiments of the given user
(so different users can have experiments with the same name).

Now what does "[queryable: ...]" mean? Here I must explain a little bit
of the inner workings of Yelandur. It's based on MongoDB, and each
resource type (user, exp, ...) corresponds to an internal model in
MongoDB.  Internally, the `user` model has exactly the attributes shown
in the above section (*Users*); but the `exp` model doesn't really have
the `owner_id` and the `collaborator_ids` attributes (and it doesn't
have the `n_results` and the `n_profiles` attributes at all).  Instead,
it has an `owner` attribute which itself has a `user_id` attribute, and
Yelandur takes `owner.user_id` as the value for `owner_id` when it
receives the `GET`.  Same for the collaborators: the model has a
`collaborators` attribute, which is a list of `user`s, and it builds
`collaborator_ids` to be the list of `user.user_id`s for each `user` in
`collaborators`.  (Finally, `n_results` and `n_profiles` don't come from
model attributes, they're computed at request-time by directly querying
the `result` and `profile` collections in the database.)

Why is this important? Because it means that, when using Django-style
queries, you can do more complex stuff by using those attributes (which
are public). So you'll be able to do a `GET
/exps?owner_id__startswith=ja` of course (which is exactly the same as
`GET /exps?owner__user_id__startswith=ja`), but you'll also be able to
do a `GET /exps?owner__gravatar_id__startswith=9e26` if for example you
only know a user by his `gravatar_id` (this example sounds a little
stupid, but that query depth can come in useful with other resources
further down). On the other hand, you can't go deep into the `n_results`
and `n_profiles` values (because they're computed at request-time, they
don't exist in the database model): so only things like `GET
/exps?n_results__gt=3000`, and nothing like `GET
/exps?results__count__gt=3000` (this would return a `400` error).

#### `/exps/<exp_id>`

##### `GET`

`GET /exps/<exp_id>` works like its `users` counterpart. E.g. `GET
/exps/3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153`
returns:

```json
{
    "exp": {
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "name": "numerical-distance",
        "description": "The numerical distance experiment, on smartphones",
        "owner_id": "jane",
        "collaborator_ids": ["sophia", "bill"],
        "n_results": 24819,
        "n_profiles": 312
    }
}
```

This is the same if you are logged in as the owner, one of the
collaborators, or anybody else (or not logged in), since all the
available information is public.

A `GET` on a non-existing experiment returns a `404`.

##### `PUT`

Not implemented yet.

##### `DELETE`

Not implemented yet.

#### `/exps`

##### `GET`

`GET /exps` returns the array of all experiments, only including public
data (which is everything, for now):

```json
{
    "exps": [
        {
            "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "name": "numerical-distance",
            "description": "The numerical distance experiment, on smartphones",
            "owner_id": "jane",
            "collaborator_ids": ["sophia", "bill"],
            "n_results": 24819,
            "n_profiles": 312
        },
        {
            "exp_id": "3812bfcf957e8534a683a37ffa3d09a9db9a797317ac20edc87809711e0d47cb",
            "name": "gender-priming",
            "description": "Controversial gender priming effects",
            "owner_id": "beth",
            "collaborator_ids": ["william", "bill"],
            "n_results": 4887,
            "n_profiles": 98
        },
        ...
    ]
}
```

Django-style arguments can be added. So `GET
/exps?collaborators__contains=bill` would return both experiments shown
above. Again, query arguments are only allowed on public fields, and a
`403` will be returned when trying to query using other fields (if
private fields are introduced later on). A `400` error is returned if
trying to query non-existing fields. If no experiment matching the query
is found, an empty array is returned (instead of a `404`).

##### `POST`

`POST /exps` creates an experiment for the currently logged in user, and
returns the completed object with its `exp_id`. Possible fields are:

* `owner_id` (required)
* `name` (required)
* `description` (optional)
* `collaborator_ids` (optional)

Any omitted optional field will be completed with an empty value, and
any forbidden or useless data will be ignored (e.g. the `n_results` or
`n_profiles` fields).

If the creation is successful, the full object is returned with a `201`
code (including the generated `id`). For instance, if we are logged in
as `jane`, a `POST /exps` with the following data

```json
{
    "exp": {
        "owner_id": "jane",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones"
    }
}
```

will return a `201` code with the following body:

```json
{
    "exp": {
        "exp_id": "3e95168bbb013872e4c576d5f79190e14af523e3f94af2cf46a803c3680ffb14",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones",
        "owner_id": "jane",
        "collaborator_ids": [],
        "n_results": 0,
        "n_profiles": 0
    }
}
```

Possible errors are, in the following order:

* `400` if the `POST` body is malformed (e.g. no root `exp` object, or
  bad JSON)
* `401` if there is no authentication
* `403` if `owner_id` does not match the authenticated user
* `400` again if the `name` does not fulfil the required syntax
* `409` if the `name` is already taken by another experiment for that
  user


### Devices

A fully shown device has the following fields:

* `device_id` (public)
* `vk_pem` (public)

`vk_pem` is the device's public key in PEM format (used further down for
verification of signature on profiles and results), and the `device_id`
is the SHA-256 hexadecimal hash of that string. That id is unique across
all devices (which makes sure the public key is also unique across
devices).

#### `/devices/<device_id>`

##### `GET`

A `GET /devices/<device_id>` will return the device's public
information, and authentication is not taken into account. The `GET`
returns:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

If the device is not registered, a `404` is returned.

Authentication is not taken into account here because there is no
private data in the model, so the only information possibly worth
protecting is which keys are registered and which aren't. But hiding
that means not distinguishing between a user having access to a device
(which should give a `403`), and a device not being registered (which
should give a `404`), returning the same error for both cases. That
leads to awful twists in the API with `PUT` and `POST` methods, so it's
way simpler to have all this information public, especially since it's
not particularly sensitive.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we support.

#### `/devices`

##### `GET`

`GET /devices` returns the array of all registered devices. `GET
/devices` will return something along the lines of

```json
{
    "devices": [
        {
            "device_id": "dd51a2d8a72b13f8ab395635fd51391ec2a3ee4d3bdac4aab05b5722c7c662a4",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
        },
        {
            "device_id": "e2a1698df15ea7a6b385366fa69a15ecfb3bdf24e846893be56ca9d6d4deaaea",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEYELaWxsVhIeLg1r2ASgcYA1IxTYa\nYpvi9ZnAdO/A4vm0/9u+n/fjRBCLGSgF+nmJq5yBqc6jL+aI4mseuuET7g==\n-----END PUBLIC KEY-----\n"
        },
        ...
    ]
}
```

No Django-style arguments are supported, since in the current state it
wouldn't be of any use.

##### `POST`

`POST /devices` creates a device by registering its public key for
future verifying of signatures of profiles and results. You should
`POST` with data in the following format:

```json
{
    "device": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

User authentication is again not taken into account here, since this
method is intended for real devices to register themselves. Any other
data than the `vk_pem` field is ignored.

Possible errors are, in the following order:

* `400` if the data is malformed (bad JSON, or no `vk_pem` field)
* `409` if the posted key is already registered

If the registration is successful, the full device information is
returned (i.e. with the registration id) with a `201` status code:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

The `device_id` should be recorded for further use, as it is the `id`
the device will have to present when sending a profile.


### Profiles

A profile represents information about a subject (subjects are
considered to have a one-to-one relationship with devices) collected for
the purpose of an experiment. So a profile belongs to an experiment and
optionally to a device, and the profile is the information about the
subject that is relevant to the experiment. A subject has one profile
per experiment.

This information his highly private. Retrieving is only for
authenticated users who have the profile in one of their experiments,
and modifying it can only be done with signed data from a device.

A fully shown profile has the following fields:

* `profile_id` (public)
* `vk_pem` (public)
* `exp_id` (private)
* `device_id` (optional, private)
* `data` (private)

#### `/profiles/<profile_id>`

##### `GET`

`GET /profiles/<profile_id>` will return all the information to a logged
in user who has that profile in one of his experiments, and only the
public information if the user is not logged in or if he is logged in as
someone who doesn't have that profile in one of his experiments. If the
profile doesn't exist, a `404` is returned. So for a user who has access
to the request profile (it is in one of his experiments), a `GET`
returns something like:

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1985,
            "gender": "Male",
            "occupation": "Social worker"
        }
    }
}
```

The `device_id` field may or may not be present, depending on the way
the profile was registered: a profile may be attached to a device, but
this is not mandatory. This allows several experiments to have a
different profile for each experiments (but for the same subject) and
pool the trust they have in their subject between experiments (i.e. it
provides a means of identifying that profile `A` and profile `B` are in
fact the same trustworthy person, while still having separate records
for the different types of information you might want to know for each
experiment).

If no user is logged in, or for a user who doesn't have access to the
requested profile, a `GET` returns:

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n"
    }
}
```

##### `PUT`

`PUT`ing a profile can only be done by a profile or a device, so no user
authentication is taken into account here. We only consider signature of
data, as explained below.

There are two degrees of modification for a profile:

* Either you only change the `data` object (i.e. the real content of the
  profile), in which case the `PUT` body must be signed by the profile's
  private key. This makes sure only the creator of the profile can
  modify its data.
* Or you are also adding a `device_id` to profile that doesn't have any.
  This means attaching an existing profile to an existing device, and
  can only be done once. When doing this, the `PUT` body must be signed
  by *both* the profile's private key and the device's private key. This
  makes sure both the creator of the profile and the creator of the
  device agree to modify this data (in practice, it's to make sure those
  two creators are in fact the same).

In both cases, signing follows the [Draft JSON Web
Signature](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html)
specification, and is further detailed in the *Signing* section at the
end of the document.

Let's start with the first case. A `PUT
/profiles/d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232`
with the following signed data (signed with the profile's private key)

```json
{
    "profile": {
        "data": {
            "occupation": "Consultant"
        }
    }
}
```

will update that subject's `occupation`. Any other fields included
included outside of the `data` object will be ignored, except if it is a
`device_id` (see below). Note that the actual data sent doesn't look
like that, because of the signature (again, see the *Signing* section
below for details on the signature format).

For the second case, a `PUT
/profiles/3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4`
with the following data signed by *both the profile and the device*

```json
{
    "profile": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c"
    }
}
```

will attach that profile to that device. Again, the actual data sent
doesn't look like that because of the signatures. You can also add a
`data` object like in the first case, and all modifications get done in
one go.

The number of signatures found on the `PUT`ed data determines which case
we are in. In both cases, possible errors are, in the following order:

* `404` if the URL-provided `profile_id` does not exist
* `400` if the received data is malformed, which can be because of:
  * malformed or missing signature(s)
  * malformed JSON after decoding the signature(s)
* In the case where there are two signatures, a `404` if the `device_id`
  to be added does not exist
* In the case where there are two signatures, a `403` if there isn't
  exactly one valid from the `device_id` and one valid from the
  `profile_id`
* In the case where there is only one signature, a `403` if that
  signature is not from the provided `profile_id`
* In the case where there are two signatures, a `403` if the `device_id`
  has already been set on the target profile (regardless if a
  `device_id` is included in the `PUT` or not)

In all cases, if a `profile_id` field is provided in the body of the
`PUT` it is ignored (even if not the same as the URL one). If a
`device_id` is provided but there is only one signature, it is ignored
(even if the target profile already had a different `device_id`).

If the update is successful, a `200` status code is returned along will
the complete profile.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we provide.

#### `/profiles`

##### `GET`

`GET /profiles` will return the array of all profiles, with only public
information. A `GET` returns something like:

```json
{
    "profiles": [
        {
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n"
        },
        {
            "profile_id": "3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n"
        },
        ...
    ]
}
```

If no profile is found, and empty array is returned (instead of a
`404`).

##### `POST`

Creating a profile is done with a signed `POST /profiles`. You can
create a profile attached to an existing device, or without device.
Required fields are:

* `vk_pem`
* `exp_id`

Providing a `device_id` field will only work if the corresponding device
has also signed the sent data.

For example, `POST`ing the following signed data (signed by the private
key corresponding to the claimed public key)

```json
{
    "profile": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "Hydraulics engineer"
        }
    }
}
```

will create the corresponding profile without any ties to a device.
Additional unauthorized data (like a `profile_id` field) is ignored.
Possible errors are:

FIXME: errors overlap

* `400` if the received data is malformed (malformed or missing
  signature, malformed JSON after decoding the signature), or if one of
  the required fields is missing
* `403` if the signature is wrong, or if the claimed experiment does not
  exist
* `409` if the claimed public key is already registered

If the registration is successful, a `201` code is returned with the
following body (which includes the created `id`):

```json
{
    "profile": {
        "profile_id": "3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "Hydraulics engineer"
        }
    }
}
```

Registering a profile with an attached device is the same process, but
you must additionally provide a `device_id` field and include the
device's signature.

Possible errors are:

FIXME: errors overlap

* `400` if the received data is malformed (malformed or missing
  signatures, malformed JSON after decoding the signatures), or if one
  of the required fields is missing (e.g. two signatures but no
  `device_id` field)
* `403` if one of the signatures is wrong, if either the claimed
  experiment or the claimed device do not exist
* `409` if the claimed public key is already registered

If successful, the full profile is returned with a `201` status code.
The new `id` should be recorded to be provided in future communications,
for instance when uploading experiment results.


### Results

#### `/results/<result_id>`

##### `GET`

#### `/results`

##### `GET`

##### `POST`


### Signing
