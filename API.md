Yelandur API
============

Current version of the API is `1`.

Yelandur serves its API from `domain.com/vX` where `X` is the current
API version. Anything above that (e.g. `domain.com/`) returns a `404`
error. Therefore you must prepend `/vX` to all your API calls. This
will be shown in the first few examples below.


Version 1
---------

The API uses JSON as base format, and tries to follow the guidelines set
down by the [Ember.js REST
Adapter](http://emberjs.com/guides/models/the-rest-adapter/), i.e.:

* A dedicated top-level endpoint for each resource
* All data is encapsulated in a root object
* Any relationships to other objects are reflected as references to the
  `id`s of the linked objects
* Some resources can be transferred (in one direction or the other)
  individually or in arrays (always encapsulated in their root), and
  eventually it will be possible to sideload linked objects (but only in
  the server -> client direction)

All this should become clearer in the examples below.


### About resources

All resources have public and private fields. Querying a resource will default to showing you only the public fields, as if you were not logged in. Adding an `access=private` uri argument will restrict the results to items to which you have full access, showing both public and private data for those.


### Auth

All requests that modify data (`POST`, `PUT`, `DELETE`) require
authentication. All requests that involve experiment results or somehow
private data also require authentication.

For now only users can be authenticated (that is, researchers accessing
data generated by their experiments), but authenticating devices is in
the works (so that device users can retrieve their previously uploaded
results).

Authentication is done thanks to [BrowserID /
Persona](https://login.persona.org/). The callback given to the
BrowserID protocol is `/auth/browserid/login` (i.e.
`/v1/auth/browserid/login`); if authentication is successful, a session
cookie is set.

When testing manually, you can authenticate using
[Naja](https://github.com/wehlutyk/naja) (the Ajax frontend) and then
make your API requests directly in-browser.

`GET /auth/browserid/logout` (so `/v1/auth/browserid/logout` really)
clears the session cookie, i.e. logs the user out.


### Users

Users are identified by their login name, i.e. `user_id`. Being
authenticated will give you access to requests that modify data, and
show you additional private data in results.

A fully shown user has the following properties:

* `user_id` (public)
* `user_id_is_set` (public)
* `gravatar_id` (public)
* `n_profiles` (public)
* `n_devices` (public)
* `n_exps` (public)
* `n_results` (public)
* `persona_email` (private)

The `user_id` will be the user's login name, and is unique across all
users. The `persona_email` will be the user's personal email adress
(also unique), obtained through BrowserID / Persona.  The `gravatar_id`
is the md5 hexadecimal hash of the `personal_email` (as described in the
[Gravatar documentation](http://en.gravatar.com/site/implement/hash/)).

#### `/users/<user_id>`

##### `GET`

`GET /users/<user_id>` (so `/v1/users/<user_id>`) gets public
information about the user identified by `user_id`. If you are
authenticated as being that user and ask for `access=private`, private information (e.g. email
address) is included.

So `GET /users/jane` returns

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_exps": 4,
        "n_results": 65412
    }
}
```

(Note the root object encapsulation, mentioned in the
guidelines above.) Authentication is ignored here.

If you're authenticated as `jane` and you add an `access=private` argument, you'll get additional private
information (here, only the email attached to the user's Persona (i.e.
BrowserID)):

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_exps": 4,
        "n_results": 65412,
        "persona_email": "jane@example.com"
    }
}
```

Any `GET` on a non-existing user (or deleted or disabled, if those are
implemented further down the road) will return an error with a `404`
status code:

```json
{
    "error": {
        "exception": "DoesNotExist",
        "exception_message": "User matching query does not exist.",
        "explanation": "The requested user was not found"
    }
}
```

Asking for `access=private` with no authentication will return a `401`, and asking for a user you don't have access to with an `access=private` will return a `403`.

##### `PUT`

A `PUT` operation requires to be authenticated as the user you will be
modifying. `PUT`ing a user with new information will modify that user's
data. Currently the only allowed operation is to set the user's
`user_id`, and it can only be done once. The reason is that new users
are created only through Persona / BrowserID: when a unknown user logs
in with Persona, the server receives his associated email address, and
sets the `user_id` of the newly created user to be that email address.
Querying such a user with `GET /users/bill@example.com?access=private` will yield:

```json
{
    "user": {
        "user_id": "bill@example.com",
        "user_id_is_set": "false",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_exps": 4,
        "n_results": 65412,
        "persona_email": "bill@example.com"
    }
}
```

(Note the `"user_id_is_set": "false"` field.)

It is then necessary to set the user's `user_id` (to prevent other users
from easily obtaining his email address) with a `PUT
/users/bill@example.com` with the following data:

```json
{
    "user": {
        "user_id": "bill-the-researcher"
    }
}
```

Any other data included will be ignored. Possible errors (always
accompanied by explanations) are, in the following order:

* `404` if the URL-provided `user_id` does not exist
* `401` if there is no authentication
* `400` if the received data is malformed (e.g. does not have the root
  `user` object, or is bad JSON)
* `400` if there is no `user_id` (missing required field)
* `403` if you are authenticated as another user than the one your are
  `PUT`ing to, or if the `user_id` has already been set (i.e. if
  `user_id_is_set` is `true`)
* `400` again if the JSON `user_id` does not fulfil the required syntax
* `409` if the JSON `user_id` is already taken by another user

If the update is successful, the updated user is returned with a `200`
code:

```json
{
    "user": {
        "user_id": "bill-the-researcher",
        "user_id_is_set": "true",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_exps": 4,
        "n_results": 65412,
        "persona_email": "bill@example.com"
    }
}
```

This operation can only be done once because the user's `user_id` is his
unique identifier on the server, which is not allowed to change once he
has started creating resources. Other operations led by a user will be
refused if his `user_id` has not been set.

##### `DELETE`

Not implemented yet. This needs to decide what different types of
deletion we provide.

#### `/users/me`

##### `GET`

This operation requires authentication, and is used to find out which
user a client is logged in as. If you are logged in as `jane`, `GET /users/me` will return the same as `GET /users/jane?access=private`:

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_exps": 4,
        "n_results": 65412,
        "persona_email": "jane@example.com"
    }
}
```

If you are not logged in, a `401` error is returned.

#### `/users`

##### `GET`

`GET /users` returns the array of all users with only public data (even
for the one you are logged in as). So being logged in as `jane` would
still yield:

```json
{
    "users": [
        {
            "user_id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
            "n_profiles": 5412,
            "n_devices": 2657,
            "n_exps": 4,
            "n_results": 65412
        },
        {
            "user_id": "bill-the-researcher",
            "user_id_is_set": "true",
            "gravatar_id": "f5cabff22532bd0025118905bdea50da",
            "n_profiles": 3468,
            "n_devices": 2465,
            "n_exps": 3,
            "n_results": 24978
        },
        ...
    ]
}
```

If you are logged in, you can add an `access=private` argument, and the results will be restricted to the users to which you have access, including their private information. So if you are logged in as `jane` and have access only to yourself, a `GET /users?access=private` will yield:

```json
{
    "users": [
        {
            "user_id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
            "n_profiles": 5412,
            "n_devices": 2657,
            "n_exps": 4,
            "n_results": 65412,
            "persona_email": "jane@example.com"
        }
    ]
}
```

In that case, if no authentication is provided a `401` is returned. If no users matching your query are found, an empty array is returned.

TODO: Django-style arguments.

### Exps

A fully shown experiment has the following fields:

* `exp_id` (public)
* `name` (public)
* `description` (public)
* `owner_id` (public)
* `collaborator_ids` (public)
* `n_results` (public)
* `n_profiles` (public)
* `n_devices` (public)

The `exp_id` is the SHA-256 hexadecimal hash of the string obtained by
putting the `owner_id` and the `name` together, separated by a `/`. In
python:

```python
from hashlib import sha256
print sha256(owner_id + '/' + name).hexdigest()
```

This id is unique across all experiments of all users, which means the
experiment's `name` is unique across all experiments of the given user
(so different users can have experiments with the same name).

#### `/exps/<exp_id>`

##### `GET`

`GET /exps/<exp_id>` works like its `users` counterpart. E.g. `GET
/exps/3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153`
returns:

```json
{
    "exp": {
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "name": "numerical-distance",
        "description": "The numerical distance experiment, on smartphones",
        "owner_id": "jane",
        "collaborator_ids": ["sophia", "bill"],
        "n_results": 24819,
        "n_profiles": 312,
        "n_devices": 312
    }
}
```

This is the same if you are logged in as the owner, one of the
collaborators, or anybody else (or not logged in), since all the
available information is public. The `access=private` paramater is ignored here, since all information available is public.

A `GET` on a non-existing experiment returns a `404`.

##### `PUT`

Not implemented yet.

##### `DELETE`

Not implemented yet.

#### `/exps`

##### `GET`

`GET /exps` returns the array of all experiments, only including public
data (which is everything, for now):

```json
{
    "exps": [
        {
            "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "name": "numerical-distance",
            "description": "The numerical distance experiment, on smartphones",
            "owner_id": "jane",
            "collaborator_ids": ["sophia", "bill"],
            "n_results": 24819,
            "n_profiles": 312,
            "n_devices": 312
        },
        {
            "exp_id": "3812bfcf957e8534a683a37ffa3d09a9db9a797317ac20edc87809711e0d47cb",
            "name": "gender-priming",
            "description": "Controversial gender priming effects",
            "owner_id": "beth",
            "collaborator_ids": ["william", "bill"],
            "n_results": 4887,
            "n_profiles": 98,
            "n_devices": 98
        },
        ...
    ]
}
```

Here again, the `access=private` parameter is ignored (only public information is available). If no experiment matching the query
is found, an empty array is returned (instead of a `404`).

##### `POST`

`POST /exps` creates an experiment for the currently logged in user, and
returns the completed object with its `exp_id`. Possible fields are:

* `owner_id` (required)
* `name` (required)
* `description` (optional)
* `collaborator_ids` (optional)

Any omitted optional field will be completed with an empty value, and
any forbidden or useless data will be ignored (e.g. the `n_results` or
`n_profiles` fields).

If the creation is successful, the full object is returned with a `201`
code (including the generated `id`). For instance, if we are logged in
as `jane`, a `POST /exps` with the following data

```json
{
    "exp": {
        "owner_id": "jane",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones"
    }
}
```

will return a `201` code with the following body:

```json
{
    "exp": {
        "exp_id": "3e95168bbb013872e4c576d5f79190e14af523e3f94af2cf46a803c3680ffb14",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones",
        "owner_id": "jane",
        "collaborator_ids": [],
        "n_results": 0,
        "n_profiles": 0
    }
}
```

Possible errors are, in the following order:

* `401` if there is no authentication
* `400` if the `POST` body is malformed (e.g. no root `exp` object, or
  bad JSON)
* `403` if `owner_id` does not match the authenticated user
* `400` if a required field is missing
* `400` again if the `name` does not fulfil the required syntax
* `409` if the `name` is already taken by another experiment for that
  user


### Devices

A fully shown device has the following fields:

* `device_id` (public)
* `vk_pem` (public)

`vk_pem` is the device's public key in PEM format (used further down for
verification of signature on profiles and results), and the `device_id`
is the SHA-256 hexadecimal hash of that string. That id is unique across
all devices (which makes sure the public key is also unique across
devices).

#### `/devices/<device_id>`

##### `GET`

A `GET /devices/<device_id>` will return the device's public
information, and authentication is not taken into account. The `GET`
returns:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

If the device is not registered, a `404` is returned.

Authentication is not taken into account here because there is no
private data in the model, so the only information possibly worth
protecting is which keys are registered and which aren't. But hiding
that means not distinguishing between a user having access to a device
(which should give a `403`), and a device not being registered (which
should give a `404`), returning the same error for both cases. That
leads to awful twists in the API with `PUT` and `POST` methods, so it's
way simpler to have all this information public, especially since it's
not particularly sensitive.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we support.

#### `/devices`

##### `GET`

`GET /devices` returns the array of all registered devices. `GET
/devices` will return something along the lines of

```json
{
    "devices": [
        {
            "device_id": "dd51a2d8a72b13f8ab395635fd51391ec2a3ee4d3bdac4aab05b5722c7c662a4",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
        },
        {
            "device_id": "e2a1698df15ea7a6b385366fa69a15ecfb3bdf24e846893be56ca9d6d4deaaea",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEYELaWxsVhIeLg1r2ASgcYA1IxTYa\nYpvi9ZnAdO/A4vm0/9u+n/fjRBCLGSgF+nmJq5yBqc6jL+aI4mseuuET7g==\n-----END PUBLIC KEY-----\n"
        },
        ...
    ]
}
```

##### `POST`

`POST /devices` creates a device by registering its public key for
future verifying of signatures of profiles and results. You should
`POST` with data in the following format:

```json
{
    "device": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

User authentication is again not taken into account here, since this
method is intended for real devices to register themselves. Any other
data than the `vk_pem` field is ignored.

Possible errors are, in the following order:

* `400` if the data is malformed (bad JSON, or no `vk_pem` field)
* `409` if the posted key is already registered

If the registration is successful, the full device information is
returned (i.e. with the registration id) with a `201` status code:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

The `device_id` should be recorded for further use, as it is the `id`
the device will have to present when sending a profile.


### Profiles

A profile represents information about a subject (subjects are
considered to have a one-to-one relationship with devices) collected for
the purpose of an experiment. So a profile belongs to an experiment and
optionally to a device, and the profile is the information about the
subject that is relevant to the experiment. A subject has one profile
per experiment.

This information his highly private. Retrieving is only for
authenticated users who have the profile in one of their experiments,
and modifying it can only be done with signed data from a device.

A fully shown profile has the following fields:

* `profile_id` (public)
* `vk_pem` (public)
* `exp_id` (private)
* `device_id` (optional, private)
* `n_results` (private)
* `data` (private)

#### `/profiles/<profile_id>`

##### `GET`

`GET /profiles/<profile_id>` will return only public information regardless of authentication, and `GET /pprofiles/<profile_id>?access=private` will return private information if you are logged in as a user who has that profile in one of his experiments. In that case, not providing authentication will return a `401`, and querying a profile you don't have access to will return a `403`. If the requested
profile doesn't exist, a `404` is returned, before any other error. So for a user who has access
to the request profile (it is in one of his experiments), a `GET` with `access=private`
returns something like:

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "n_results": 513,
        "data": {
            "birth_year": 1985,
            "gender": "Male",
            "occupation": "Social worker"
        }
    }
}
```

The `device_id` field may or may not be present, depending on the way
the profile was registered: a profile may be attached to a device, but
this is not mandatory. This allows several experiments to have a
different profile for each experiments (but for the same subject) and
pool the trust they have in their subject between experiments (i.e. it
provides a means of identifying that profile `A` and profile `B` are in
fact the same trustworthy person, while still having separate records
for the different types of information you might want to know for each
experiment).

Without the `access=private` argument, a `GET` returns:

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n"
    }
}
```

##### `PUT`

`PUT`ing a profile can only be done by a profile or a device, so no user
authentication is taken into account here. We only consider signature of
data, as explained below.

There are two degrees of modification for a profile:

* Either you only change the `data` object (i.e. the real content of the
  profile), in which case the `PUT` body must be signed by the profile's
  private key. This makes sure only the creator of the profile can
  modify its data.
* Or you are also adding a `device_id` to profile that doesn't have any.
  This means attaching an existing profile to an existing device, and
  can only be done once. When doing this, the `PUT` body must be signed
  by *both* the profile's private key and the device's private key. This
  makes sure both the creator of the profile and the creator of the
  device agree to modify this data (in practice, it's to make sure those
  two creators are in fact the same).

In both cases, signing follows the [Draft JSON Web
Signature](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html)
specification, and is further detailed in the *Signing* section at the
end of the document.

Let's start with the first case. A `PUT
/profiles/d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232`
with the following signed data (signed with the profile's private key)

```json
{
    "profile": {
        "data": {
            "occupation": "Consultant"
        }
    }
}
```

will update that subject's `occupation`. Any other fields included
included outside of the `data` object will be ignored, except if it is a
`device_id` (see below). Note that the actual data sent doesn't look
like that, because of the signature (again, see the *Signing* section
below for details on the signature format).

For the second case, a `PUT
/profiles/3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4`
with the following data signed by *both the profile and the device*

```json
{
    "profile": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c"
    }
}
```

will attach that profile to that device. Again, the actual data sent
doesn't look like that because of the signatures. You can also add a
`data` object like in the first case, and all modifications get done in
one go.

The number of signatures found on the `PUT`ed data determines which case
we are in. In both cases, possible errors are, in the following order:

* `404` if the URL-provided `profile_id` does not exist
* `400` if the received data is malformed, which can be because of:
  * malformed or missing signature(s)
  * malformed JSON after decoding the signature(s)
* In the case where there are two signatures, a `404` if the `device_id`
  to be added does not exist
* In the case where there are two signatures, a `403` if there isn't
  exactly one valid from the `device_id` and one valid from the
  `profile_id`
* In the case where there is only one signature, a `403` if that
  signature is not from the provided `profile_id`
* In the case where there are two signatures, a `403` if the `device_id`
  has already been set on the target profile (regardless if a
  `device_id` is included in the `PUT` or not)

In all cases, if a `profile_id` field is provided in the body of the
`PUT` it is ignored (even if not the same as the URL one). If a
`device_id` is provided but there is only one signature, it is ignored
(even if the target profile already had a different `device_id`).

If the update is successful, a `200` status code is returned along will
the complete profile.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we provide.

#### `/profiles`

##### `GET`

`GET /profiles` will return the array of all profiles, including only public information. If you are logged in, you can add an `access=private` argument, which will restrict results to profiles to which you have access, and include their private information. Asking fro `access=private` and not providing authentication will return a `401`. So if you are logged in and have only access to profile
`d7e...`, a `GET` with `access=private` will return:

```json
{
    "profiles": [
        {
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
            "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
            "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "n_results": 513,
            "data": {
                "birth_year": 1985,
                "gender": "Male",
                "occupation": "Social worker"
            }
        }
    ]
}
```

If no profile is found, and empty array is returned (instead of a
`404`).

##### `POST`

Creating a profile is done with a signed `POST /profiles`. You can
create a profile attached to an existing device, or without device.
Possible fields are:

* `vk_pem` (required)
* `exp_id` (required)
* `device_id` (optional)
* `data` (optional)

Providing a `device_id` field will only work if the corresponding device
has also signed the sent data.

For example, `POST`ing the following signed data (signed by the private
key corresponding to the claimed public key)

```json
{
    "profile": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "n_results": 0,
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "Hydraulics engineer"
        }
    }
}
```

will create the corresponding profile without any ties to a device.
Additional unauthorized data (like a `profile_id` field) is ignored.

Now `POST`ing the same data with an additional `device_id`, signed by
*both the device and the private key corresponding to the claimed public
key*

```json
{
    "profile": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "n_results": 0,
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "Hydraulics engineer"
        }
    }
}
```

Here again, the number of signatures on the `POST`ed data determines
which case we're in. Possible errors are, in the following order:

* `400` if the received data is malformed, which can be because of:
  * malformed or missing signature(s)
  * malformed JSON after decoding the signature(s)
* In the case where there are two signatures, a `404` if the `device_id`
  to be added does not exist
* In the case where there are two signatures, a `403` if there isn't
  exactly one valid from the `device_id` and one valid from the private
  key corresponding to the claimed public key
* In the case where there is only one signature, a `403` if that
  signature is not valid from the claimed public key
* `400` if a required field is missing
* `409` if the claimed public key is already registered
* `404` if the claimed experiment does not exist

If the registration is successful, a `201` code is returned with the
full profile body (which includes the created id):

```json
{
    "profile": {
        "profile_id": "3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "n_results": 0,
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "Hydraulics engineer"
        }
    }
}
```

and the additional `device_id` field in the case of registration with a
device.

The new `profile_id` should be recorded to be provided in future
communications, for instance when uploading experiment results.


### Results

#### `/results/<result_id>`

##### `GET`

#### `/results`

##### `GET`

##### `POST`


### Signing
