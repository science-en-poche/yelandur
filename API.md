Yelandur API
============

Current version of the API is `v1`.

Yelandur serves its API from `domain.com/vX` where `X` is the current API
version. Anything above that (e.g. `domain.com/`) returns a `404` error.
Therefore you must prepend `/vX` to all your API calls.  This will be shown in
the first few examples below.


Version 1
---------

The API uses JSON as base format, and tries to follow the guidelines set down
by the [Ember.js REST
Adapter](http://emberjs.com/guides/models/the-rest-adapter/), i.e.:

* A dedicated top-level endpoint for each resource
* All data is encapsulated in a root object
* Any relationships to other objects are reflected as references to the `id`s
  of the linked objects
* Some resources can be transferred (in one direction or the other)
  individually or in arrays (always encapsulated in their root), and
  eventually it will be possible to sideload linked objects (but only in the
  server -> client direction)

All this should become clearer in the examples below.


### Auth

All requests that modify data (`POST`, `PUT`, `DELETE`) require
authentication. All requests that involve experiment results or somehow
private data also require authentication.

For now only users can be authenticated (that is, researchers accessing data
generated by their experiments), but authenticating devices is in the works
(so that device users can retrieve their previously uploaded results).

Authentication is done thanks to [BrowserID /
Persona](https://login.persona.org/). The callback given to the BrowserID
protocol is `/auth/browserid/login` (i.e. `/v1/auth/browserid/login`) ; if
authentication is successful, a session cookie is set.

When testing manually, you can authenticate using
[Naja](https://github.com/wehlutyk/naja) (the Ajax frontend) and then make
your API requests directly in-browser.

`GET /auth/browserid/logout` (so `/v1/auth/browserid/logout` really) clears
the session cookie, i.e. logs the user out.


### Users

Users are identified by their login name, i.e. `user_id`. Being authenticated
will give you access to requests that modify data, and show you additional
private data in results.

A fully shown user has the following properties:

* `user_id` (public)
* `user_id_is_set` (public)
* `gravatar_id` (public)
* `persona_email` (private)

#### `/users/<user_id>`

##### `GET`

`GET /users/<user_id>` (so `/v1/users/<user_id>`) gets public information
about the user identified by `user_id`. If you are authenticated as being that
user, private information (e.g. email address) is included.

So `GET /users/jane` returns

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf"
    }
}
```

if you're not authenticated or if you're authenticated as someone else than
`jane` (note the root object encapsulation, mentioned in the guidelines
above).

If you're authenticated as `jane`, you'll get additional private
information (here, only the email attached to the user's Persona (i.e.
BrowserID)):

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

Any `GET` on a non-existing user (or deleted or disabled, if those are
implemented further down the road) will return an error with a `404` status
code:

```json
{
    "error": {
        "exception": "DoesNotExist",
        "exception_message": "User matching query does not exist.",
        "explanation": "The requested user was not found"
    }
}
```

##### `PUT`

A `PUT` operation requires to be authenticated as the user you will be
modifying. `PUT`ing a user with new information will modify that user's data.
Currently the only allowed operation is to set the user's `user_id`, and it
can only be done once. The reason is that new users are created only through
Persona / BrowserID: when a unknown user logs in with Persona, the server
receives his associated email address, and sets the `user_id` of the newly
created user to be that email address. Querying such a user with `GET
/users/bill@example.com` will yield:

```json
{
    "user": {
        "user_id": "bill@example.com",
        "user_id_is_set": "false",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

(Note the `"user_id_is_set": "false"` field.)

It is then necessary to set the user's `user_id` (to prevent other users from
easily obtaining his email address) with a `PUT /users/bill@example.com` with
the following data:

```json
{
    "user": {
        "user_id": "bill@example.com",
        "user_id_claim": "bill-the-researcher"
    }
}
```

Any other data included will be ignored. Possible errors (always accompanied
by explanations) are:

* `400` if the received data is malformed (e.g. does not have the root `user`
  object, or is bad JSON), if the `user_id` doesn't match the URL `user_id`,
  or if the `user_id_claim` does not fulfil the required syntax
* `401` if there is no authentication
* `403` if you are authenticated as another user than the one your are
  `PUT`ing to, or if the `user_id` has already been set (i.e. if
  `user_id_is_set` is `true`)
* `404` if the user does not exist (before any other error)
* `409` if the `user_id_claim` is already taken by another user

If the update is successful, the updated user is returned with a `200` code:

```json
{
    "user": {
        "user_id": "bill-the-researcher",
        "user_id_is_set": "true",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

This operation can only be done once because the user's `user_id` is his
unique identifier on the server, which is not allowed to change once he has
started creating resources. Other operations led by a user will be refused if
his `user_id` has not been set.

##### `DELETE`

Not implemented yet. This needs to decide what different types of deletion we
provide.

#### `/users/me`

##### `GET`

This operation requires authentication, and is used to find out which user a
client is logged in as. If you are logged in as `jane`, `GET /users/me` will
return the same as `GET /users/jane`:

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

If you are not logged in, a `401` error is returned.

#### `/users`

##### `GET`

`GET /users` returns the array of all users with only public data (even for
the one you are logged in as). So being logged in as `jane` would still yield:

```json
{
    "users": [
        {
            "user_id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        },
        {
            "user_id": "bill-the-researcher",
            "user_id_is_set": "true",
            "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        },
        ...
    ]
}
```

Django-style arguments can be added. So `GET /users?user_id__startswith=ja`
would return users `jane` and `jack`. Query arguments are only allowed on
public fields, and a `403` will be returned when trying to query using other
fields.  If no user matching the query is found, an empty array is returned
(instead of a `404`).


### Exps

A fully shown experiment has the following fields:

* `exp_id` (public)
* `name` (public)
* `description` (public)
* `owner_id` (public)
* `collaborator_ids` (public)
* `n_results` (public)
* `n_subject` (public)

Strictly speaking, the last 4th and 5th fields represent `owner__user_id` and
the array of `collaborator__user_id` for each `collaborator` in
`collaborators` (all this in Django-style querying). But for the sake of
compatibility with Ember's data model, we provide them as shown above. All you
need to know is that, to query them, you'll be using things like `GET
/exps?owner__user_id__startswith=ja` instead of `GET
/exps?owner_id__startswith=ja`.

#### `/exps/<id>`

##### `GET`

`GET /exps/<exp_id>` works like its `users` counterpart. E.g. `GET
/exps/3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153`
returns:

```json
{
    "exp": {
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "name": "numerical-distance",
        "description": "The numerical distance experiment, on smartphones",
        "owner_id": "jane",
        "collaborator_ids": ["sophia", "bill"]
    }
}
```

This is the same if you are logged in as the owner, one of the collaborators,
or anybody else (or not logged in), since all the available information is
public.

A `GET` on a non-existing experiment returns a `404`.

##### `PUT`

Not implemented yet.

##### `DELETE`

Not implemented yet.

#### `/exps`

##### `GET`

`GET /exps` returns the array of all experiments with only public data (which
is everything, for now):

```json
{
    "exps": [
        {
            "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "name": "numerical-distance",
            "description": "The numerical distance experiment, on smartphones",
            "owner_id": "jane",
            "collaborator_ids": ["sophia", "bill"]
        },
        {
            "exp_id": "3812bfcf957e8534a683a37ffa3d09a9db9a797317ac20edc87809711e0d47cb",
            "name": "gender-priming",
            "description": "Controversial gender priming effects",
            "owner_id": "beth",
            "collaborator_ids": ["william", "bill"]
        },
        ...
    ]
}
```

Django-style arguments can be added. So `GET
/exps?collaborators__contains=bill` would return both experiments shown
above. Again, query arguments are only allowed on public fields, and a `403`
will be returned when trying to query using other fields (if private fields
are introduced later on). If no experiment matching the query is found, an
empty array is returned (instead of a `404`).

##### `POST`

`POST /exps` creates an experiment for the currently logged in user, and
returns the completed object with its `exp_id`. Required fields are:

* `owner_id`
* `name`
* `description`

Any optional omitted field will be completed with an empty value.

If the creation is successful, the full object is returned with a `201` code.

For instance, if we are logged in as `jane`, a `POST /exps` with the following
data

```json
{
    "exp": {
        "owner_id": "jane",
        "name": "motion-after-effect",
        "description": After motion effects on smartphones"
    }
}
```

will return a `201` code with the following body:

```json
{
    "exp": {
        "exp_id": "3e95168bbb013872e4c576d5f79190e14af523e3f94af2cf46a803c3680ffb14",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones",
        "owner_id": "jane",
        "collaborator_ids": []
    }
}
```

Possible errors are:

* `400` if the `POST` body is malformed (e.g. no root `exp` object, or bad
  JSON) or if the `name` does not fulfil the required syntax
* `401` if there is no authentication
* `403` if `owner_id` does not match the authenticated user
* `409` if the `name` is already taken by another experiment for that user


### Devices

A fully shown device has the following fields:

* `device_id` (public)
* `vk_pem` (private)

With devices we enter in the realm of sensitive data, that should not be
shared without careful caution. So every operation here requires
authentication (with the exception of `POST /devices` which is used by devices
themselves), and the results are restricted to the devices the user has access
to.

#### `/devices/<device_id>`

##### `GET`

A `GET /devices/<device_id>` will return the device's private information if
the user has that device in one of his experiments, and a `403` otherwise (no
`404` is ever issued, since that would let people know which devices are
registered and which aren't). The `GET` returns:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

A `401` is returned if no authentication is provided.

##### `PUT`

Not implemented yet. Will be used to add a profile associated to the device.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we support.

#### `/devices`

##### `GET`

`GET /devices` returns the array of all devices the user has access to. `GET
/devices` will return something along the lines of

```json
{
    "devices": [
        {
            "device_id": "dd51a2d8a72b13f8ab395635fd51391ec2a3ee4d3bdac4aab05b5722c7c662a4",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
        },
        {
            "device_id": "e2a1698df15ea7a6b385366fa69a15ecfb3bdf24e846893be56ca9d6d4deaaea",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEYELaWxsVhIeLg1r2ASgcYA1IxTYa\nYpvi9ZnAdO/A4vm0/9u+n/fjRBCLGSgF+nmJq5yBqc6jL+aI4mseuuET7g==\n-----END PUBLIC KEY-----\n"
        },
        ...
    ]
}
```

Here again, Django-style arguments can be added, although in the current state
that will hardly be of any use.

A `401` is returned if the user is not authenticated.

##### `POST`

`POST /devices` creates a device by registering its public key for future
verifying of signatures of profiles and results. You should `POST` with data
in the following format:

```json
{
    "device": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

user authentication is not taken into account here, since this method is
intended for real devices to register themselves. Any other data than the
`vk_pem` one is ignored.

Possible errors are:

* `400` if the data is malformed (bad JSON, or no `vk_pem` field)
* `409` if the posted key is already registered

If the registration is successful, the full device information is returned
(i.e. with the registration `id`) with a `201` status code:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

The `device_id` should be recorded for further use, as it is the `id` the
device will have to present when sending results.


### Subjects

#### `/subjects/<subject_id>`

##### `GET`

##### `PUT`

##### `DELETE`

#### `/subjects`

##### `GET`

##### `POST`


### Results

#### `/results/<result_id>`

##### `GET`

#### `/results`

##### `GET`

##### `POST`
