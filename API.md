Yelandur API
============

Current version of the API is `v1`.

Yelandur serves its API from `domain.com/vX` where `X` is the current API
version. Anything above that (e.g. `domain.com/`) returns a `404` error.
Therefore you must prepend `/vX` to all your API calls.  This will be shown in
the first few examples below.


Version 1
---------

The API uses JSON as base format, and tries to follow the guidelines set down
by the [Ember.js REST
Adapter](http://emberjs.com/guides/models/the-rest-adapter/), i.e.:

* A dedicated top-level endpoint for each resource
* All data is encapsulated in a root object
* Any relationships to other objects are reflected as references to the `id`s
  of the linked objects
* Some resources can be transferred (in one direction or the other)
  individually or in arrays (always encapsulated in their root), and
  eventually it will be possible to sideload linked objects (but only in the
  server -> client direction)

All this should become clearer in the examples below.


### Auth

All requests that modify data (`POST`, `PUT`, `DELETE`) require
authentication. All requests that involve experiment results or somehow
private data also require authentication.

For now only users can be authenticated (that is, researchers accessing data
generated by their experiments), but authenticating devices is in the works
(so that device users can retrieve their previously uploaded results).

Authentication is done thanks to [BrowserID /
Persona](https://login.persona.org/). The callback given to the BrowserID
protocol is `/auth/browserid/login` (i.e. `/v1/auth/browserid/login`) ; if
authentication is successful, a session cookie is set.

When testing manually, you can authenticate using
[Naja](https://github.com/wehlutyk/naja) (the Ajax frontend) and then make
your API requests directly in-browser.

`GET /auth/browserid/logout` (so `/v1/auth/browserid/logout` really) clears
the session cookie, i.e. logs the user out.


### Users

Users are identified by their login name, i.e. `user_id`. Being authenticated
will give you access to requests that modify data, and show you additional
private data in results.

A fully shown user has the following properties:

* `user_id` (public)
* `user_id_is_set` (public)
* `gravatar_id` (public)
* `persona_email` (private)

#### `/users/<user_id>`

##### `GET`

`GET /users/<user_id>` (so `/v1/users/<user_id>`) gets public information
about the user identified by `user_id`. If you are authenticated as being that
user, private information (e.g. email address) is included.

So `GET /users/jane` returns

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf"
    }
}
```

if you're not authenticated or if you're authenticated as someone else than
`jane` (note the root object encapsulation, mentioned in the guidelines
above).

If you're authenticated as `jane`, you'll get additional private
information (here, only the email attached to the user's Persona (i.e.
BrowserID)):

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

Any `GET` on a non-existing user (or deleted or disabled, if those are
implemented further down the road) will return an error with a `404` status
code:

```json
{
    "error": {
        "exception": "DoesNotExist",
        "exception_message": "User matching query does not exist.",
        "explanation": "The requested user was not found"
    }
}
```

##### `PUT`

A `PUT` operation requires to be authenticated as the user you will be
modifying. `PUT`ing a user with new information will modify that user's data.
Currently the only allowed operation is to set the user's `user_id`, and it
can only be done once. The reason is that new users are created only through
Persona / BrowserID: when a unknown user logs in with Persona, the server
receives his associated email address, and sets the `user_id` of the newly
created user to be that email address. Querying such a user with `GET
/users/bill@example.com` will yield:

```json
{
    "user": {
        "user_id": "bill@example.com",
        "user_id_is_set": "false",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

(Note the `"user_id_is_set": "false"` field.)

It is then necessary to set the user's `user_id` (to prevent other users from
easily obtaining his email address) with a `PUT /users/bill@example.com` with
the following data:

```json
{
    "user": {
        "user_id": "bill@example.com",
        "user_id_claim": "bill-the-researcher"
    }
}
```

Any other data included will be ignored. Possible errors (always accompanied
by explanations) are:

* `400` if the received data is malformed (e.g. does not have the root `user`
  object, or is bad JSON), if the `user_id` doesn't match the URL `user_id`,
  or if the `user_id_claim` does not fulfil the required syntax
* `401` if there is no authentication
* `403` if you are authenticated as another user than the one your are
  `PUT`ing to, or if the `user_id` has already been set (i.e. if
  `user_id_is_set` is `true`)
* `404` if the user does not exist (before any other error)
* `409` if the `user_id_claim` is already taken by another user

If the update is successful, the updated user is returned with a `200` code:

```json
{
    "user": {
        "user_id": "bill-the-researcher",
        "user_id_is_set": "true",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

This operation can only be done once because the user's `user_id` is his
unique identifier on the server, which is not allowed to change once he has
started creating resources. Other operations led by a user will be refused if
his `user_id` has not been set.

##### `DELETE`

Not implemented yet. This needs to decide what different types of deletion we
provide.

#### `/users/me`

##### `GET`

This operation requires authentication, and is used to find out which user a
client is logged in as. If you are logged in as `jane`, `GET /users/me` will
return the same as `GET /users/jane`:

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

If you are not logged in, a `401` error is returned.

#### `/users`

##### `GET`

`GET /users` returns the array of all users with only public data (even for
the one you are logged in as). So being logged in as `jane` would still yield:

```json
{
    "users": [
        {
            "user_id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        },
        {
            "user_id": "bill-the-researcher",
            "user_id_is_set": "true",
            "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        },
        ...
    ]
}
```

Django-style arguments can be added. So `GET /users?user_id__startswith=ja`
would return users `jane` and `jack`. Query arguments are only allowed on
public fields, and a `403` will be returned when trying to query using other
fields.  If no user matching the query is found, an empty array is returned
(instead of a `404`).


### Exps

A fully shown experiment has the following fields:

* `exp_id` (public)
* `name` (public)
* `description` (public)
* `owner_id` (public)
* `collaborator_ids` (public)
* `n_results` (public)
* `n_profiles` (public)

Strictly speaking, the 4th and 5th fields represent `owner__user_id` and the
array of `collaborator__user_id` for each `collaborator` in `collaborators`
(all this in Django-style querying). But for the sake of compatibility with
Ember's data model, we provide them as shown above. All you need to know is
that, to query them, you'll be using things like `GET
/exps?owner__user_id__startswith=ja` instead of `GET
/exps?owner_id__startswith=ja`.

#### `/exps/<id>`

##### `GET`

`GET /exps/<exp_id>` works like its `users` counterpart. E.g. `GET
/exps/3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153`
returns:

```json
{
    "exp": {
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "name": "numerical-distance",
        "description": "The numerical distance experiment, on smartphones",
        "owner_id": "jane",
        "collaborator_ids": ["sophia", "bill"],
        "n_results": 24819,
        "n_profiles": 312
    }
}
```

This is the same if you are logged in as the owner, one of the collaborators,
or anybody else (or not logged in), since all the available information is
public.

A `GET` on a non-existing experiment returns a `404`.

##### `PUT`

Not implemented yet.

##### `DELETE`

Not implemented yet.

#### `/exps`

##### `GET`

`GET /exps` returns the array of all experiments with only public data (which
is everything, for now):

```json
{
    "exps": [
        {
            "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "name": "numerical-distance",
            "description": "The numerical distance experiment, on smartphones",
            "owner_id": "jane",
            "collaborator_ids": ["sophia", "bill"],
            "n_results": 24819,
            "n_profiles": 312
        },
        {
            "exp_id": "3812bfcf957e8534a683a37ffa3d09a9db9a797317ac20edc87809711e0d47cb",
            "name": "gender-priming",
            "description": "Controversial gender priming effects",
            "owner_id": "beth",
            "collaborator_ids": ["william", "bill"],
            "n_results": 4887,
            "n_profiles": 98
        },
        ...
    ]
}
```

Django-style arguments can be added. So `GET
/exps?collaborators__contains=bill` would return both experiments shown
above. Again, query arguments are only allowed on public fields, and a `403`
will be returned when trying to query using other fields (if private fields
are introduced later on). If no experiment matching the query is found, an
empty array is returned (instead of a `404`).

##### `POST`

`POST /exps` creates an experiment for the currently logged in user, and
returns the completed object with its `exp_id`. Required fields are:

* `owner_id`
* `name`
* `description`

Any omitted optional field will be completed with an empty value, and any
forbidden or useless data will be ignored (e.g. the `n_results` or
`n_profiles` fields).

If the creation is successful, the full object is returned with a `201` code
(including the generated `id`). For instance, if we are logged in as `jane`,
a `POST /exps` with the following data

```json
{
    "exp": {
        "owner_id": "jane",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones"
    }
}
```

will return a `201` code with the following body:

```json
{
    "exp": {
        "exp_id": "3e95168bbb013872e4c576d5f79190e14af523e3f94af2cf46a803c3680ffb14",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones",
        "owner_id": "jane",
        "collaborator_ids": [],
        "n_results": 0,
        "n_profiles": 0
    }
}
```

Possible errors are:

* `400` if the `POST` body is malformed (e.g. no root `exp` object, or bad
  JSON) or if the `name` does not fulfil the required syntax
* `401` if there is no authentication
* `403` if `owner_id` does not match the authenticated user
* `409` if the `name` is already taken by another experiment for that user


### Devices

A fully shown device has the following fields:

* `device_id` (private)
* `vk_pem` (private)

With devices we enter in the realm of sensitive data, that should not be
shared without careful caution. So every operation here requires
authentication (with the exception of `POST /devices` which is used by devices
themselves), and the results are restricted to the devices the user has access
to.

#### `/devices/<device_id>`

##### `GET`

A `GET /devices/<device_id>` will return the device's private information if
the user has that device in one of his experiments, and a `403` if he doesn't.
The `GET` returns:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

A `401` is returned if no authentication is provided. If the device is not
registered, a `404` is returned (yes, that distinction lets attackers learn
which `id`s are registered and which aren't, but avoiding that leads to awful
twists in the API with `PUT` and `POST` methods ; and it's not really
sensitive information).

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we support.

#### `/devices`

##### `GET`

`GET /devices` returns the array of all devices the user has access to. `GET
/devices` will return something along the lines of

```json
{
    "devices": [
        {
            "device_id": "dd51a2d8a72b13f8ab395635fd51391ec2a3ee4d3bdac4aab05b5722c7c662a4",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
        },
        {
            "device_id": "e2a1698df15ea7a6b385366fa69a15ecfb3bdf24e846893be56ca9d6d4deaaea",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEYELaWxsVhIeLg1r2ASgcYA1IxTYa\nYpvi9ZnAdO/A4vm0/9u+n/fjRBCLGSgF+nmJq5yBqc6jL+aI4mseuuET7g==\n-----END PUBLIC KEY-----\n"
        },
        ...
    ]
}
```

Here again, Django-style arguments can be added, although in the current state
that will hardly be of any use.

A `401` is returned if the user is not authenticated.

##### `POST`

`POST /devices` creates a device by registering its public key for future
verifying of signatures of profiles and results. You should `POST` with data
in the following format:

```json
{
    "device": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

User authentication is not taken into account here, since this method is
intended for real devices to register themselves. Any other data than the
`vk_pem` field is ignored.

Possible errors are:

* `400` if the data is malformed (bad JSON, or no `vk_pem` field)
* `409` if the posted key is already registered

If the registration is successful, the full device information is returned
(i.e. with the registration `id`) with a `201` status code:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

The `device_id` should be recorded for further use, as it is the `id` the
device will have to present when sending a profile.


### Profiles

A profile represents information about a subject (subjects are considered to
have a one-to-one relationship with devices) collected for the purpose of an
experiment. So a profile belongs to an experiment and optionally to a device,
and the profile is the information that is relevant to the experiment. A
subject has one profile per experiment.

This information his highly private. Retrieving is only for authenticated
users who have the profile in one of their experiments, and modifying it can
only be done with signed data from a device.

A fully shown profile has the following fields:

* `profile_id` (private)
* `vk_pem` (private)
* `exp_id` (private)
* `device_id` (optional, private)
* `data` (private)

#### `/profiles/<profile_id>`

##### `GET`

`GET /profiles/<profile_id>` will return all the information to a logged in
user who has that profile in one of his experiments ; if the user does not
have access to that profile, a `403` is returned. If no authentication is
provided a `401` is returned. A `GET` returns something like:

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1985,
            "gender": "Male",
            "occupation": "Social worker"
        }
    }
}
```

The `device_id` field may or may not be present, depending on the way the
profile was registered: a profile may be attached to a device, but this is not
mandatory. This allows several experiments to have a different profile for
each experiments (but for the same subject) and pool the trust they have in
their subject between experiments (i.e. it provides a means of identifying
that profile `A` and profile `B` are in fact the same trustworthy person,
while still having separate records for the different types of information you
might want to know for each experiment).

If the profile is not registered, a `404` is returned (yes again, that
distinction lets attackers learn which profiles are registered and which
aren't, but avoiding that again leads to awful twists in the API with `PUT`
and `POST` methods ; and it's not really sensitive information).

##### `PUT`

A profile can only be modified by itself, meaning `PUT` operations must be
signed by the profile's private key. Signing follows the [Draft JSON Web
Signature](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html)
specification, and is further detailed in the *Signing* section at the end of
the document. A `PUT` operation signed by the profile can modify any field
inside the `data` object, and nothing else. It is also possible to attach an
existing profile to an existing device, i.e. adding a `device_id` field to a
profile that doesn't have one ; that operation is detailed further down.

A `PUT
/profiles/d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232`
with the following signed data

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "data": {
            "occupation": "Consultant"
        }
    }
}
```

will update that subject's `occupation`. Any other data included will be
ignored, except if it is a `device_id` (see below). Note that the actual data
sent doesn't look like that, because of the signature (again, see the
*Signing* section below for details on the signature format).

Possible errors are:

FIXME: errors overlap

* `400` if the received data is malformed (malformed or missing signature,
  malformed JSON after decoding the signature), if the `profile_id` field is
  missing, if the `profile_id` field does not match the one in the URL
* `403` if the signature is not from the provided `profile_id`, or if there is
  a `device_id` that does not match the existing one (if the server-side
  `device_id` is not set, it can be added if a signature from the device is
  also provided, as explained below)
* `404` if the profile given in the URL does not exist (before any other
  error)

If the update is successful, a `200` status code is returned along will the
complete profile.

As mentioned above, it is also possible to attach an existing profile to an
existing device. E.g. `PUT
/profiles/3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4`
with the following data signed by *both the profile and the device*

```json
{
    "profile": {
        "profile_id": "3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c"
    }
}
```

will attach that profile to that device. Again, the actual data sent doesn't
look like that because of the signature.

Possible errors are:

FIXME: errors overlap

* `400` if the received data is malformed (malformed or missing signature,
  malformed JSON after decoding the signatures), if the `profile_id` field is
  missing, if there are two signatures but no `device_id` field, or if the
  `profile_id` does not match the one in the URL
* `403` if one of the signatures is wrong or missing, if the device in the
  provided data does not exist, of if the server-side profile already has a
  `device_id` set
* `404` if the profile in the URL does not exist (before any other error)

If the update is successful, a `200` status code is returned along will the
complete profile.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we provide.

#### `/profiles`

##### `GET`

`GET /profiles` requires user authentication and will return the array of
profiles that appear in of the user's experiments. If no authentication is
provided a `401` is returned. A `GET` returns something like:

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1985,
            "gender": "Male",
            "occupation": "Social worker"
        }
    },
    "profile": {
        "profile_id": "3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "Hydraulics engineer"
        }
    },
    ...
}
```

You can of course include Django-style parameters, for instance restricting
the data to the profiles whose `birth_year` is before 1982, with a `GET
/profiles?data__birth_year__lte=1982`.

##### `POST`

Creating a profile is done with a signed `POST /profiles`. You can create a
profile attached to an existing device, or without device. Required fields
are:

* `vk_pem`
* `exp_id`

Providing a `device_id` field will only work if the corresponding device has
also signed the sent data.

For example, `POST`ing the following signed data (signed by the private key
corresponding to the claimed public key)

```json
{
    "profile": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "Hydraulics engineer"
        }
    }
}
```

will create the corresponding profile without any ties to a device. Additional
unauthorized data (like a `profile_id` field) is ignored. Possible errors are:

FIXME: errors overlap

* `400` if the received data is malformed (malformed or missing signature,
  malformed JSON after decoding the signature), or if one of the required
  fields is missing
* `403` if the signature is wrong, or if the claimed experiment does not exist
* `409` if the claimed public key is already registered

If the registration is successful, a `201` code is returned with the following
body (which includes the created `id`):

```json
{
    "profile": {
        "profile_id": "3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "Hydraulics engineer"
        }
    }
}
```

Registering a profile with an attached device is the same process, but you
must additionally provide a `device_id` field and include the device's
signature.

Possible errors are:

FIXME: errors overlap

* `400` if the received data is malformed (malformed or missing signatures,
  malformed JSON after decoding the signatures), or if one of the required
  fields is missing (e.g. two signatures but no `device_id` field)
* `403` if one of the signatures is wrong, if either the claimed experiment or
  the claimed device do not exist
* `409` if the claimed public key is already registered

If successful, the full profile is returned with a `201` status code. The new
`id` should be recorded to be provided in future communications, for instance
when uploading experiment results.


### Results

#### `/results/<result_id>`

##### `GET`

#### `/results`

##### `GET`

##### `POST`


### Signing
