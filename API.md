Yelandur API
============

Current version of the API is `1`.

Yelandur serves its API from `domain.com/vX` where `X` is the current
API version. Anything above that (e.g. `domain.com/`) returns a `404`
error. Therefore you must prepend `/vX` to all your API calls. This
will be shown in the first few examples below.


Version 1
---------

The API uses JSON as base format, and tries to follow the guidelines set
down by the [Ember.js REST
Adapter](http://emberjs.com/guides/models/the-rest-adapter/), i.e.:

* A dedicated top-level endpoint for each resource
* All data is encapsulated in a root object
* Any relationships to other objects are reflected as references to the
  `id`s of the linked objects
* Some resources can be transferred (in one direction or the other)
  individually or in arrays (always encapsulated in their root), and
  eventually it will be possible to sideload linked objects (but only in
  the server -> client direction)

All this should become clearer in the examples below.


### About resources

All resources have public and private fields. Querying a resource will
default to showing you only the public fields, as if you were not logged
in. Adding an `access=private` URI argument will restrict the results to
items to which you have full access, showing both public and private
data for those.


### Auth

All requests that modify data (`POST`, `PUT`, `DELETE`) require
authentication. All requests that involve experiment results or somehow
private data also require authentication.

You can authenticate either as a user (that is, researchers accessing data
generated by their experiments), or as a profile (i.e. subjects' devices
retrieving results they uploaded).

User authentication is done thanks to [BrowserID /
Persona](https://login.persona.org/). The callback given to the
BrowserID protocol is `/auth/browserid/login` (i.e.
`/v1/auth/browserid/login`); if authentication is successful, a session
cookie is set.

When testing manually, you can authenticate using
[Naja](https://github.com/wehlutyk/naja) (the Ajax frontend) and then
make your API requests directly in-browser.

`GET /auth/browserid/logout` (so `/v1/auth/browserid/logout` really)
clears the session cookie, i.e. logs the user out.

Profile authentication is done by signing requests with the profile's private
key. See the section about signing at the end of this document for more
details.

TODO: force addition of a `requestTimestamp` field in the body of signed-auth
requests, checking the timestamp is +/-30 seconds from the time at which it is
received. This prevents reuse of intercepted signed data.


### Users

Users are identified by their login name, i.e. `id`. Being authenticated will
allow requests that modify data, and show you additional private data in
results.

A fully shown user has the following properties:

TODO: add a syntax definition for `id`.

* `id` (public)
* `user_id_is_set` (public)
* `gravatar_id` (public)
* `exp_ids` (public)
* `n_profiles` (public)
* `n_devices` (public)
* `n_results` (public)
* `persona_email` (private)

The `id` will be the user's login name, and is unique across all
users. The `persona_email` will be the user's personal email address
(also unique), obtained through BrowserID / Persona.  The `gravatar_id`
is the md5 hexadecimal hash of the `personal_email` (as described in the
[Gravatar documentation](http://en.gravatar.com/site/implement/hash/)).

#### `/users/<id>`

##### `GET`

`GET /users/<id>` (so `/v1/users/<id>`) gets public
information about the user identified by `id`. If you are
authenticated as being that user and ask for `access=private`, private
information (e.g. email address) is included.

So `GET /users/jane` returns

```json
{
    "user": {
        "id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "exp_ids": [
            "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
            "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
        ],
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_results": 65412
    }
}
```

(Note the root object encapsulation, mentioned in the
guidelines above.) Authentication is ignored here.

If you're authenticated as `jane` and you add an `access=private`
argument, you'll get additional private information (here, only the
email attached to the user's Persona (i.e.  BrowserID)):

```json
{
    "user": {
        "id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "exp_ids": [
            "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
            "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
        ],
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_results": 65412,
        "persona_email": "jane@example.com"
    }
}
```

Any `GET` on a non-existing user (or deleted or disabled, if those are
implemented further down the road) will return an error with a `404`
status code:

```json
{
    "error": {
        "status_code": 404,
        "type": "DoesNotExist",
        "message": "Item does not exist"
    }
}
```

Asking for `access=private` with no authentication will return a `401`, and
asking for a user other than yourself with an `access=private` will return a
`403` (and a `404` instead if the requested user does not exist).

##### `PUT`

A `PUT` operation requires to be authenticated as the user you will be
modifying. `PUT`ing a user with new information will modify that user's data.
Currently the only allowed operation is to set the user's `id`, and it can only
be done once. The reason is that new users are created only through Persona /
BrowserID: when a unknown user logs in with Persona, the server receives his
associated email address, and sets the `id` of the newly created user to be the
part of the email address before the `@` sign, extended with `-XXX` where `XXX`
are three random hexadecimal characters Querying such a user with e.g. `GET
/users/bill-he3?access=private` will yield:

```json
{
    "user": {
        "id": "bill-he3",
        "user_id_is_set": "false",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "exp_ids": [],
        "n_profiles": 0,
        "n_devices": 0,
        "n_results": 0,
        "persona_email": "bill@example.com"
    }
}
```

(Note the `"user_id_is_set": "false"` field.)

It is then necessary to set the user's `id` (to prevent other users
from easily obtaining his email address) with a `PUT
/users/bill-he3` with the following data:

```json
{
    "user": {
        "id": "bill-the-researcher"
    }
}
```

Any other data included will be ignored. Possible errors (always
accompanied by explanations) are, in the following order:

* `404` if the URL-provided `id` does not exist
* `401` if there is no authentication
* `400` if the received data is malformed (e.g. does not have the root `user`
  object, or is bad JSON)
* `400` if there is no `id` (missing required field)
* `403` if you are authenticated as another user than the one you are `PUT`ing
  to, or if the `id` has already been set (i.e. if `user_id_is_set` is `true`)
* `400` again if the JSON `id` does not fulfill the required syntax
* `409` if the JSON `id` is reserved (either `new` or `settings`)
* `409` if the JSON `id` is already taken by another user

If the update is successful, the updated user is returned with a `200`
code:

```json
{
    "user": {
        "id": "bill-the-researcher",
        "user_id_is_set": "true",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "exp_ids": [],
        "n_profiles": 0,
        "n_devices": 0,
        "n_results": 0,
        "persona_email": "bill@example.com"
    }
}
```

This operation can only be done once because the user's `id` is his
unique identifier on the server, which is not allowed to change once he
has started creating resources. Other operations led by a user will be
refused if his `id` has not been set.

##### `DELETE`

Not implemented yet. This needs to decide what different types of
deletion we provide.

#### `/users/me`

##### `GET`

This operation requires authentication, and is used to find out which
user a client is logged in as. If you are logged in as `jane`, `GET
/users/me` will return the same as `GET /users/jane?access=private`:

```json
{
    "user": {
        "id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "exp_ids": [
            "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
            "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
        ],
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_results": 65412,
        "persona_email": "jane@example.com"
    }
}
```

If you are not logged in, a `401` error is returned.

#### `/users`

##### `GET`

`GET /users` returns the array of all users with only public data (even
for the one you are logged in as). So being logged in as `jane` would
still yield (note there is no `persona_email` field):

```json
{
    "users": [
        {
            "id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
            "exp_ids": [
                "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
                "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
            ],
            "n_profiles": 5412,
            "n_devices": 2657,
            "n_results": 65412
        },
        {
            "id": "bill-the-researcher",
            "user_id_is_set": "true",
            "gravatar_id": "f5cabff22532bd0025118905bdea50da",
            "exp_ids": [],
            "n_profiles": 0,
            "n_devices": 0,
            "n_results": 0
        },
        ...
    ]
}
```

If you are logged in, you can add an `access=private` argument, and the results
will be restricted to yourself but will include private information. So if you
are logged in as `jane`, a `GET /users?access=private` will yield:

```json
{
    "users": [
        {
            "id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
            "exp_ids": [
                "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
                "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
            ],
            "n_profiles": 5412,
            "n_devices": 2657,
            "n_results": 65412,
            "persona_email": "jane@example.com"
        }
    ]
}
```

In that case, if no authentication is provided a `401` is returned.

Finally, you can ask for specific users by specifying an `ids[]=<id>` URL
parameter for each user you want to retrieve; the array of requested users is
returned. Adding `access=private` will give you private information if you have
access to it, a `401` if you don't authenticate, or a `403` if you're asking
for a user other than yourself. So e.g. `GET /users?ids[]=jane&access=private`
will return the full private information about jane in a `users` array (if you
are authenticated as `jane`). If a requested user is not found, it will not be
included in the results (instead of returning a `404`).


### Exps

A fully shown experiment has the following fields:

* `id` (public)
* `name` (public)
* `description` (public)
* `owner_id` (public)
* `collaborator_ids` (public)
* `n_results` (public)
* `n_profiles` (public)
* `n_devices` (public)

The `id` is the SHA-256 hexadecimal hash of the string obtained by
putting the `owner_id` and the `name` together, separated by a `/`. In
python:

```python
from hashlib import sha256
print sha256(owner_id + '/' + name).hexdigest()
```

This id is unique across all experiments of all users, which means the
experiment's `name` is unique across all experiments of the given user
(so different users can have experiments with the same name).

#### `/exps/<id>`

##### `GET`

`GET /exps/<id>` works like its `users` counterpart. E.g. `GET
/exps/3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153`
returns:

```json
{
    "exp": {
        "id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "name": "numerical-distance",
        "description": "The numerical distance experiment, on smartphones",
        "owner_id": "jane",
        "collaborator_ids": ["sophia", "bill"],
        "n_results": 24819,
        "n_profiles": 312,
        "n_devices": 312
    }
}
```

This is the same if you are logged in as the owner, one of the
collaborators, or anybody else (or not logged in), since all the
available information is public. The `access=private` parameter is
ignored here, since all information available is public.

A `GET` on a non-existing experiment returns a `404`.

##### `PUT`

Not implemented yet.

##### `DELETE`

Not implemented yet.

#### `/exps`

##### `GET`

`GET /exps` returns the array of all experiments, only including public
data (which is everything, for now):

```json
{
    "exps": [
        {
            "id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "name": "numerical-distance",
            "description": "The numerical distance experiment, on smartphones",
            "owner_id": "jane",
            "collaborator_ids": ["sophia", "bill"],
            "n_results": 24819,
            "n_profiles": 312,
            "n_devices": 312
        },
        {
            "id": "3812bfcf957e8534a683a37ffa3d09a9db9a797317ac20edc87809711e0d47cb",
            "name": "gender-priming",
            "description": "Controversial gender priming effects",
            "owner_id": "beth",
            "collaborator_ids": ["william", "bill"],
            "n_results": 4887,
            "n_profiles": 98,
            "n_devices": 98
        },
        ...
    ]
}
```

Here again, the `access=private` parameter is ignored (only public
information is available). If no experiment matching the query is found,
an empty array is returned (instead of a `404`).

Finally, just as with the users, you can ask for specific experiments by
providing `ids[]=<id>` URL arguments. If an exp is not found, it is
silently not included in the results (instead of returning a `404`).

##### `POST`

`POST /exps` creates an experiment for the currently logged in user,
and returns the completed object with its `id`. Possible fields are:

TODO: add a description of allowed syntax for exp name.

* `owner_id` (required)
* `name` (required)
* `description` (optional)
* `collaborator_ids` (optional)

Any omitted optional field will be completed with an empty value, and
any forbidden or useless data will be ignored (e.g. the `n_results` or
`n_profiles` fields).

If the creation is successful, the full object is returned with a `201`
code (including the generated `id`). For instance, if we are logged in
as `jane`, a `POST /exps` with the following data

```json
{
    "exp": {
        "owner_id": "jane",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones"
    }
}
```

will return a `201` code with the following body:

```json
{
    "exp": {
        "id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones",
        "owner_id": "jane",
        "collaborator_ids": [],
        "n_results": 0,
        "n_profiles": 0
    }
}
```

Possible errors are, in the following order:

* `401` if there is no authentication
* `400` if the `POST` body is malformed (e.g. no root `exp` object, or
  bad JSON)
* `403` if `owner_id` does not match the authenticated user
* `403` if the future owner does not have his `id` set
* `400` if a required field is missing
* `400` if one of the claimed collaborators does not exist or his
  `id` is not set
* `400` if the owner is in the collaborators
* `400` again if the `name` does not fulfill the required syntax
* `409` if the `name` is already taken by another experiment for that
  user


### Devices

A fully shown device has the following fields:

* `id` (public)
* `vk_pem` (public)

`vk_pem` is the device's public key in PEM format (used further down for
verification of signature on profiles and results), and the `id`
is the SHA-256 hexadecimal hash of that string. That id is unique across
all devices (which makes sure the public key is also unique across
devices).

#### `/devices/<id>`

##### `GET`

TODO: adapt terminology to device-auth

A `GET /devices/<id>` will return the device's public
information, and authentication is not taken into account. The `GET`
returns:

```json
{
    "device": {
        "id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

If the device is not registered, a `404` is returned.

Authentication is not taken into account here because there is no
private data in the model, so the only information possibly worth
protecting is which keys are registered and which aren't. But hiding
that means not distinguishing between a user having access to a device
(which should give a `403`), and a device not being registered (which
should give a `404`), returning the same error for both cases. That
leads to awful twists in the API with `PUT` and `POST` methods, so it's
way simpler to have all this information public, especially since it's
not particularly sensitive.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we support.

#### `/devices`

##### `GET`

TODO: adapt terminology to device-auth

`GET /devices` returns the array of all registered devices. `GET
/devices` will return something along the lines of

```json
{
    "devices": [
        {
            "id": "dd51a2d8a72b13f8ab395635fd51391ec2a3ee4d3bdac4aab05b5722c7c662a4",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
        },
        {
            "id": "e2a1698df15ea7a6b385366fa69a15ecfb3bdf24e846893be56ca9d6d4deaaea",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEYELaWxsVhIeLg1r2ASgcYA1IxTYa\nYpvi9ZnAdO/A4vm0/9u+n/fjRBCLGSgF+nmJq5yBqc6jL+aI4mseuuET7g==\n-----END PUBLIC KEY-----\n"
        },
        ...
    ]
}
```

Specific devices can again be requested by adding `ids[]=<id>` URL
arguments.

##### `POST`

TODO: adapt terminology to device-auth

`POST /devices` creates a device by registering its public key for
future verifying of signatures of profiles and results. You should
`POST` with data in the following format:

```json
{
    "device": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

User authentication is again not taken into account here, since this
method is intended for real devices to register themselves. Any other
data than the `vk_pem` field is ignored.

Possible errors are, in the following order:

* `400` if the data is malformed (bad JSON, or no `vk_pem` field)
* `409` if the posted key is already registered

If the registration is successful, the full device information is
returned (i.e. with the registration id) with a `201` status code:

```json
{
    "device": {
        "id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

The `id` should be recorded for further use, as it is the `id`
the device will have to present when sending a profile.


### Profiles

A profile represents information about a subject (subjects are
considered to have a one-to-one relationship with devices) collected for
the purpose of an experiment. So a profile belongs to an experiment and
optionally to a device, and the profile is the information about the
subject that is relevant to the experiment. A subject has one profile
per experiment.

This information his highly private. Retrieving is only for
authenticated users who have the profile in one of their experiments,
and modifying it can only be done with signed data from a device.

A fully shown profile has the following fields:

* `id` (public)
* `vk_pem` (public)
* `exp_id` (private)
* `device_id` (optional, private)
* `n_results` (private)
* `profile_data` (private)

`vk_pem` is the profile's public key in PEM format (used further down
for verification of signature on results), and the `id` is the
SHA-256 hexadecimal hash of that string. That id is unique across all
profiles (which makes sure the public key is also unique across
profiles).

#### `/profiles/<id>`

##### `GET`

TODO: Get with profile-auth for private data

`GET /profiles/<id>` will return only public information
regardless of authentication, and `GET
/profiles/<id>?access=private` will return private information
if you are logged in as a user who has that profile in one of his
experiments. In that case, not providing authentication will return a
`401`, and querying a profile you don't have access to will return a
`403`. If the requested profile doesn't exist, a `404` is returned,
before any other error. So for a user who has access to the requested
profile (it is in one of his experiments), a `GET` with `access=private`
returns something like:

```json
{
    "profile": {
        "id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "n_results": 513,
        "profile_data": {
            "birth_year": 1985,
            "gender": "Male",
            "occupation": "social worker"
        }
    }
}
```

The `device_id` field may be `null` or not, depending on the way
the profile was registered: a profile may be attached to a device, but
this is not mandatory. This allows several experiments to have a
different profile for each experiment (but for the same subject) and
pool the trust they have in their subject between experiments (i.e. it
provides a means of identifying that profile `A` and profile `B` are in
fact the same trustworthy person, while still having separate records
for the different types of information you might want to know for each
experiment).

Without the `access=private` argument, a `GET` returns:

```json
{
    "profile": {
        "id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n"
    }
}
```

##### `PUT`

TODO: Adapt terminology for profile-auth

`PUT`ing a profile can only be done by a profile or a device, so no user
authentication is taken into account here. We only consider signature of
data, as explained below.

There are two degrees of modification for a profile:

* Either you only change the `profile_data` object (i.e. the real content of
  the profile), in which case the `PUT` body must be signed by the profile's
  private key. This makes sure only the creator of the profile can modify its
  data.
* Or you are also adding a `device_id` to a profile that doesn't have any. This
  means attaching an existing profile to an existing device, and can only be
  done once. When doing this, the `PUT` body must be signed by *both* the
  profile's private key and the device's private key. This makes sure both the
  creator of the profile and the creator of the device agree to modify this
  data (in practice, it's to make sure those two creators are in fact the
  same).

In both cases, signing follows version 14 of the [Draft JSON Web
Signature](http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-14)
specification, and is further detailed in the *Signing* section at the
end of the document.

Let's start with the first case. A `PUT
/profiles/d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232`
with the following signed data (signed with the profile's private key)

```json
{
    "profile": {
        "profile_data": {
            "birth_year": 1985,
            "gender": "Male",
            "occupation": "lover"
        }
    }
}
```

will update that subject's `occupation`. Note that the whole `profile_data`
field is replaced by the provided one. Any other fields included outside of the
`profile_data` object will be ignored, except if it is a `device_id` (see
below). Note that the actual data sent doesn't look like that, because of the
signature (again, see the *Signing* section below for details on the signature
format).

For the second case, a `PUT
/profiles/3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4`
with the following data signed by *both the profile and the device*

```json
{
    "profile": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c"
    }
}
```

will attach that profile to that device. Again, the actual data sent doesn't
look like that because of the signatures. You can also add a `profile_data`
object like in the first case, and all modifications get done in one go.

The number of signatures found on the `PUT`ed data determines which case
we are in. In both cases, possible errors are, in the following order:

* `404` if the URL-provided `id` does not exist
* `400` if the received data is malformed, which can be because of:
  * malformed, missing, or too many signature(s)
  * malformed JSON or missing fields
* In the case where there are two signatures, a `400` if the `device_id` to be
  added does not exist
* In the case where there are two signatures, a `403` if there isn't exactly
  one valid from the `device_id` and one valid from the profile's `id`
* In the case where there is only one signature, a `403` if that signature is
  not from the provided profile's `id`
* `400` if `profile_data` is present but is not a JSON object
* In the case where there are two signatures, a `403` if the `device_id` has
  already been set on the target profile

In all cases, if an `id` field is provided in the body of the `PUT` it is
ignored (even if not the same as the URL one). If a `device_id` is provided but
there is only one signature, it is ignored (even if the target profile already
had a different `device_id`). Finally, note that when `PUT`ing, any provided
`profile_data` field will replace the existing one: so `PUT`ing an empty
`profile_data` field empties the profile of its information. It works the other
way around at the above level: if a profile has a device set, `PUT`ing
information without a `device_id` will not delete the device from the profile's
information, because that tie is irreversible.

If the update is successful, a `200` status code is returned along will
the complete profile.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we provide.

#### `/profiles`

##### `GET`

TODO: Get with profile-auth for private data

`GET /profiles` will return the array of all profiles, including only
public information. If you are logged in, you can add an
`access=private` argument, which will restrict results to profiles to
which you have access, and include their private information. Asking for
`access=private` and not providing authentication will return a `401`.
So if you are logged in and have only access to profile `d7e...`, a
`GET` with `access=private` will return:

```json
{
    "profiles": [
        {
            "id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
            "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
            "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "n_results": 513,
            "profile_data": {
                "birth_year": 1985,
                "gender": "Male",
                "occupation": "social worker"
            }
        }
    ]
}
```

If no profile is found, an empty array is returned (instead of a
`404`).

Specific profiles can again be requested by adding `ids[]=<id>` URL
arguments.

##### `POST`

TODO: Adapt terminology for profile-auth

Creating a profile is done with a signed `POST /profiles`. You can
create a profile attached to an existing device, or without device.
Possible fields are:

* `vk_pem` (required)
* `exp_id` (required)
* `device_id` (optional)
* `profile_data` (optional)

Providing a `device_id` field will only work if the corresponding device
has also signed the sent data.

For example, `POST`ing the following signed data (signed by the private
key corresponding to the claimed public key)

```json
{
    "profile": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "profile_data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "hydraulics engineer"
        }
    }
}
```

will create the corresponding profile without any ties to a device.
Additional unauthorized data (like an `id` field) is ignored.

Now `POST`ing the same data with an additional `device_id`, signed by
*both the device and the private key corresponding to the claimed public
key*

```json
{
    "profile": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "profile_data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "hydraulics engineer"
        }
    }
}
```

will create the corresponding profile without tied to its device.

Here again, the number of signatures on the `POST`ed data determines
which case we're in. Possible errors are, in the following order:

* `400` if the received data is malformed, which can be because of:
  * malformed, missing, or too many signature(s)
  * malformed JSON or missing fields
* In the case where there are two signatures, a `400` if the `device_id`
  to be added does not exist
* In the case where there are two signatures, a `403` if there isn't
  exactly one valid from the `device_id` and one valid from the
  private key corresponding to the claimed public key
* In the case where there is only one signature, a `403` if that
  signature is not valid from the claimed public key
* `400` if `profile_data` is present but is not a JSON object
* `400` if the claimed experiment does not exist
* `409` if the claimed public key is already registered

If the registration is successful, a `201` code is returned with the
full profile body (which includes the created id):

```json
{
    "profile": {
        "id": "3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "device_id": null,
        "n_results": 0,
        "profile_data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "hydraulics engineer"
        }
    }
}
```

and the proper `device_id` field in the case of registration with a
device.

The new `id` should be recorded to be provided in future
communications, for instance when uploading experiment results.


### Results

A result is some information sent in by a profile (i.e. physically by a
device) that's relevant to an experiment. This information is again
highly private, and is only for users who own (or collaborate with) the
experiment for which this data is a result.

A fully shown result has the following data:

* `id` (public)
* `profile_id` (private)
* `exp_id` (private)
* `created_at` (private)
* `result_data` (private)

The `id` is the SHA-256 hexadecimal hash of the concatenation of the
`profile_id`, an `@` sign, the `created_at` timestamp (`created_at` is in ISO
8601 format, i.e. `YYYY-MM-DDTHH:MM:SS.mmmmmmZ`), a `/` sign, and the compact
JSON representation of the `result_data` object. In python:

```python
from hashlib import sha256
from json import dumps
print sha256(profile_id + '@' + created_at +
             '/' + dumps(data, separators=(',', ':'))).hexdigest()
```

This makes sure the `id` is unique in all circumstances.

#### `/results/<id>`

##### `GET`

TODO: Get with profile-auth

`GET /results/<id>` will return only public information
regardless of authentication. `GET /results/<id>?access=private`
will return private information if you are logged in as a user owning
(or collaborating with) the target experiment for the result. In that
case, not providing authentication will return a `401`, and asking for a
result that's not in one of your experiments will return a `403`.

A `GET` without the `access=private` argument returns something like:

```json
{
    "result": {
        "id": "6af292d69252ccdd64718f06208485d05e9b8edd585a33dd20b54bb977c37367"
    }
}
```

A `GET` with the `access=private` argument returns something like:

```json
{
    "result": {
        "id": "b53cd061f4b101a3c476b8cd3bf029dbca6a6f4b93bad6d952392cdbc40163b9",
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
        "created_at": "2013-06-14T15:52:40.216842Z",
        "result_data": {
            "trials": [
                {
                    "real_orientation": 32,
                    "perceived_orientation": 44
                },
                ...
            ]
        }
    }
}
```

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we support.

#### `/results`

##### `GET`

`GET /results` returns the array of all results, including only public
information. If you are authenticated (either as user or profile), you can add
an `access=private` argument, which will restrict response to results you have
access to (if a user, results that are in your experiments; if a profile,
results you uploaded) and include their private information. Asking for
`access=private` and not providing authentication will return a `401`. So if
you are logged in as a user and have only one experiment with two results, a
`GET /results?access=private` will return:

```json
{
    "results": [
        {
            "id": "b53cd061f4b101a3c476b8cd3bf029dbca6a6f4b93bad6d952392cdbc40163b9",
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
            "created_at": "2013-06-14T15:52:40.216842Z",
            "result_data": {
                "trials": [
                    {
                        "real_orientation": 32,
                        "perceived_orientation": 44
                    },
                    ...
                ]
            }
        },
        {
            "id": "8c27752820b699626a2bd3c6e3410604bdd79aa5b34f7c540951a443054a1ac8",
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
            "created_at": "2013-06-14T15:53:52.916708Z",
            "result_data": {
                "trials": [
                    {
                        "real_orientation": 181,
                        "perceived_orientation": 207
                    },
                    ...
                ]
            }
        }
    ]
}
```

And similarly for a profile-authenticated request.

If no results are found, an empty array is returned.

Specific results can again be requested by adding `ids[]=<id>` URL
arguments.

##### `POST`

TODO: Adapt terminology for profile-auth

`POST`ing results can only be done by a profile, which means posted data
must be signed by the author profile. Possible fields in the `POST` body
are:

* `profile_id` (required)
* `result_data` (required)

Any other data provided will be ignored.

So for instance posting the following signed data (signed by the private
key corresponding to the `device_id`'s public key)

```json
{
    "result": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "result_data": {
            "trials": [
                {
                    "real_orientation": 295,
                    "perceived_orientation": 271
                },
                ...
            ]
        }
    }
}
```

will create the corresponding result, and return a `201` with the
completed result information:

```json
{
    "result": {
        "id": "0cdcf10103a0de0bbc5a920d1e8c673e4ae8b54f06851e5cb600453bdca08a38",
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
        "created_at": "2013-06-14T16:02:39.002963Z",
        "result_data": {
            "trials": [
                {
                    "real_orientation": 295,
                    "perceived_orientation": 271
                },
                ...
            ]
        }
    }
}
```

Possible errors are, in the following order:

* `400` if the received data is malformed, which can be because of:
  * malformed, missing, or too many signature(s)
  * malformed JSON or missing fields
* `400` if the claimed `profile_id` does not exist (since it is needed for
  signature validation)
* `403` if the signature is invalid
* `400` if `result_data` is not a JSON object

Results can also be sent in bulk, reducing the number of http requests
needed. Still signing the data, you can `POST` the following:

```json
{
    "results": [
        {
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "result_data": {...}
        },
        {
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "result_data": {...}
        }
    ]
}
```

which will create both results in one go. The same errors apply. Note
that if you could theoretically post to different experiments at the
same time, only one signature is allowed on this endpoint so you can't
post from different profiles at the same time, (the one signature will
not be valid for all profiles); that in turn excludes posting to
different experiments at the same time, since a profile only has one
experiment. So a `400` will be returned if the `profile_id`s aren't all
the same. If the `POST` is successful, the array of completed results is
returned with a `201` status code.


### Signing

Signing uses the JWS Json Serialization format explained in version 14
of the [Draft JSON Web
Signature](http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-14)
specification, which you might want to read if you want to understand
what's happening in the next lines. The JSON Serialization of the JWS is
explained in [section
7.2](http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-14#section-7.2)
of the draft specification.

The server-side implementation is using
[python-ecdsa](https://github.com/warner/python-ecdsa) and
[python-jws](https://github.com/brianloveswords/python-jws) for
signature verification, so only the algorithms supported by python-jws
(excluding RSA)
and the keys supported by python-ecdsa are supported. I recommend:

* Algorithm ES256: ECDSA using P-256 curve and SHA-256 hash algorithm.
  ECDSA for the conciseness of the keys, and P-256 curve because
  anything larger takes ages to sign on a regular phone.
* Curve: NIST256p. That curve is also called secp256r1 in [Bouncy
  Castle](http://www.bouncycastle.org/) (the main crypto library for
  Android), and prime256v1 in OpenSSL (it's the same curve, named
  differently by three different standards bodies).

Those are the parameters used with the [Daydreaming
experiment](https://github.com/wehlutyk/daydreaming).


### Profile Authentication

TODO: explain
* create JSON with `{"id": <id>, "timestamp": <timestamp>}`, sign, and
  send base64 encoding of body + `.` + base64 encoding of signature as
  `auth_token` url query parameter.
TODO: adapt so that this is really JWS-compliant


#### Examples

TODO: add reference to an example signing cycle
