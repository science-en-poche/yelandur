Yelandur API
============

Current version of the API is `v1`.

Yelandur serves its API from `domain.com/vX` where `X` is the current API
version. Anything above that (e.g. `domain.com/`) returns a `404` error.
Therefore you must prepend `/vX` to all your API calls.  This will be shown in
the first few examples below.


Version 1
---------

The API uses JSON as base format, and tries to follow the guidelines set down
by the [Ember.js REST
Adapter](http://emberjs.com/guides/models/the-rest-adapter/), i.e.:

* A dedicated top-level endpoint for each resource
* All data is encapsulated in a root object
* Any relationships to other objects are reflected as references to the `id`s
  of the linked objects
* Some resources can be transferred (in one direction or the other)
  individually or in arrays (always encapsulated in their root), and
  eventually it will be possible to sideload linked objects (but only in the
  server -> client direction)

All this should become clearer in the examples below.


### Auth

All requests that modify data (`POST`, `PUT`, `DELETE`) require
authentication. All requests that involve experiment results or somehow
private data also require authentication.

For now only users can be authenticated (that is, researchers accessing data
generated by their experiments), but authenticating devices is in the works
(so that device users can retrieve their previously uploaded results).

Authentication is done thanks to [BrowserID /
Persona](https://login.persona.org/). The callback given to the `BrowserID`
protocol is `/auth/browserid/login` (i.e. `/v1/auth/browserid/login`) ; if
authentication is successful, a session cookie is set.

When testing manually, you can authenticate using
[Naja](https://github.com/wehlutyk/naja) (the Ajax frontend) and then make
your API requests directly in-browser.

`GET /auth/browserid/logout` (so `/v1/auth/browserid/logout` really) clears
the session cookie, i.e. logs the user out.


### Users

Users are identified by their login name, i.e. `id`. Being authenticated will
give you access to requests that modify data, and show you additional private
data in results.

A fully shown user has the following properties:

* `id` (public)
* `id_is_set` (public)
* `gravatar_id` (public)
* `persona_email` (private)

#### `/users/<id>`

##### `GET`

`GET /users/<id>` (so `/v1/users/<id>`) gets public information about the user
identified by `id`. If you are authenticated as being that user, private
information (e.g. email address) is included.

So `GET /users/jane` returns

```json
{
    "user": {
        "id": "jane",
        "id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf"
    }
}
```

if you're not authenticated or if you're authenticated as someone else than
`jane` (note the root object encapsulation, mentioned in the guidelines
above).

If you're authenticated as `jane`, you'll get additional private
information (here, only the email attached to the user's Persona (i.e.
BrowserID)):

```json
{
    "user": {
        "id": "jane",
        "id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

Any `GET` on a non-existing user (or deleted or disabled, if those are
implemented further down the road) will return an error with a `404` status
code:

```json
{
    "error": {
        "exception": "DoesNotExist",
        "exception_message": "User matching query does not exist.",
        "explanation": "The requested user was not found"
    }
}
```

##### `PUT`

A `PUT` operation requires to be authenticated as the user you will be
modifying. `PUT`ing a user with new information will modify that user's data.
Currently the only allowed operation is to set the user's `id`, and it can
only be done once. The reason is that new users are created only through
Persona / BrowserID: when a unknown user logs in with Persona, the server
receives his associated email address, and sets the `id` of the newly created
user to be that email address. Querying such a user with `GET
/users/bill@example.com` will yield:

```json
{
    "user": {
        "id": "bill@example.com",
        "id_is_set": "false",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

(Note the `"id_is_set": "false"` field.)

It is then necessary to set the user's `id` (to prevent other users from
easily obtaining his email address) with a `PUT /users/bill@example.com` with
the following data:

```json
{
    "user": {
        "id": "bill@example.com",
        "id_claim": "bill-the-researcher"
    }
}
```

Any other data included will be ignored. Possible errors (always accompanied
by explanations) are:

* `400` if the received data is malformed (e.g. does not have the root `user`
  object, or is bad JSON), if the `id` doesn't match the current `id`, or if
  the `id_claim` does not fulfil the required syntax
* `401` if there is no authentication
* `403` if you are authenticated as another user than `bill@example.com`, or
  if the `id` has already been set (i.e. if `id_is_set` is `true`)
* `404` if the user does not exist (before any other error)
* `409` if the `id_claim` is already taken by another user

If the update is successful, the updated user is returned with a `200` code:

```json
{
    "user": {
        "id": "bill-the-researcher",
        "id_is_set": "true",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

This operation can only be done once because the user's `id` is his unique
identifier on the server, which is not allowed to change once he has started
creating resources. Other operations led by a user will be refused if his `id`
has not been set.

##### `DELETE`

Not implemented yet. This needs to decide what different types of deletion we
provide.

#### `/users/me`

##### `GET`

This operation requires authentication, and is used to find out which user a
client is logged in as. If you are logged in as `jane`, `GET /users/me` will
return the same as `GET /users/jane`:

```json
{
    "user": {
        "id": "jane",
        "id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

If you are not logged in, a `401` error is returned.

No URL options are taken into account on this endpoint.

#### `/users`

##### `GET`

`GET /users` returns the array of all users with only public data (even for
the one you are logged in as). So being logged in as `jane` would still yield:

```json
{
    "users": [
        {
            "id": "jane",
            "id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        },
        {
            "id": "bill-the-researcher",
            "id_is_set": "true",
            "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        },
        ...
    ]
}
```

Django-style arguments can be added. So `GET /users?id_startswith=ja` would
return users `jane` and `jack`. Query arguments are only allowed on public
fields, and a `403` will be returned when trying to query using other fields.
If no user matching the query is found, an empty array is returned (and not a
`404`).


### Exps

A fully shown experiment has the following fields:

* `id` (public)
* `name` (public)
* `description` (public)
* `owner_id` (public)
* `collaborator_ids` (public)

#### `/exps/<id>`

##### `GET`

##### `PUT`

##### `DELETE`

#### `/exps`

##### `GET`

##### `POST`


### Devices

#### `/devices/<id>`

##### `GET`

##### `PUT`

##### `DELETE`

#### `/devices`

##### `GET`

##### `POST`


### Subjects

#### `/subjects/<id>`

##### `GET`

##### `PUT`

##### `DELETE`

#### `/subjects`

##### `GET`

##### `POST`


### Results

#### `/results/<id>`

##### `GET`

#### `/results`

##### `GET`

##### `POST`
