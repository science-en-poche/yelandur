Yelandur API
============

Current version of the API is `1`.

Yelandur serves its API from `domain.com/vX` where `X` is the current
API version. Anything above that (e.g. `domain.com/`) returns a `404`
error. Therefore you must prepend `/vX` to all your API calls. This
will be shown in the first few examples below.


Version 1
---------

The API uses JSON as base format, and tries to follow the guidelines set
down by the [Ember.js REST
Adapter](http://emberjs.com/guides/models/the-rest-adapter/), i.e.:

* A dedicated top-level endpoint for each resource
* All data is encapsulated in a root object
* Any relationships to other objects are reflected as references to the
  `id`s of the linked objects
* Some resources can be transferred (in one direction or the other)
  individually or in arrays (always encapsulated in their root), and
  eventually it will be possible to sideload linked objects (but only in
  the server -> client direction)

All this should become clearer in the examples below.


### About resources

All resources have public and private fields. Querying a resource will
default to showing you only the public fields, as if you were not logged
in. Adding an `access=private` URI argument will restrict the results to
items to which you have full access, showing both public and private
data for those.


### Auth

All requests that modify data (`POST`, `PUT`, `DELETE`) require
authentication. All requests that involve experiment results or somehow
private data also require authentication.

For now only users can be authenticated (that is, researchers accessing
data generated by their experiments), but authenticating devices is in
the works (so that device users can retrieve their previously uploaded
results).

Authentication is done thanks to [BrowserID /
Persona](https://login.persona.org/). The callback given to the
BrowserID protocol is `/auth/browserid/login` (i.e.
`/v1/auth/browserid/login`); if authentication is successful, a session
cookie is set.

When testing manually, you can authenticate using
[Naja](https://github.com/wehlutyk/naja) (the Ajax frontend) and then
make your API requests directly in-browser.

`GET /auth/browserid/logout` (so `/v1/auth/browserid/logout` really)
clears the session cookie, i.e. logs the user out.


### Users

Users are identified by their login name, i.e. `user_id`. Being
authenticated will give you access to requests that modify data, and
show you additional private data in results.

A fully shown user has the following properties:

* `user_id` (public)
* `user_id_is_set` (public)
* `gravatar_id` (public)
* `exp_ids` (public)
* `n_profiles` (public)
* `n_devices` (public)
* `n_results` (public)
* `persona_email` (private)

The `user_id` will be the user's login name, and is unique across all
users. The `persona_email` will be the user's personal email adress
(also unique), obtained through BrowserID / Persona.  The `gravatar_id`
is the md5 hexadecimal hash of the `personal_email` (as described in the
[Gravatar documentation](http://en.gravatar.com/site/implement/hash/)).

#### `/users/<user_id>`

##### `GET`

`GET /users/<user_id>` (so `/v1/users/<user_id>`) gets public
information about the user identified by `user_id`. If you are
authenticated as being that user and ask for `access=private`, private
information (e.g. email address) is included.

So `GET /users/jane` returns

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "exp_ids": [
            "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
            "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
        ],
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_results": 65412
    }
}
```

(Note the root object encapsulation, mentioned in the
guidelines above.) Authentication is ignored here.

If you're authenticated as `jane` and you add an `access=private`
argument, you'll get additional private information (here, only the
email attached to the user's Persona (i.e.  BrowserID)):

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "exp_ids": [
            "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
            "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
        ],
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_results": 65412,
        "persona_email": "jane@example.com"
    }
}
```

Any `GET` on a non-existing user (or deleted or disabled, if those are
implemented further down the road) will return an error with a `404`
status code:

```json
{
    "error": {
        "status_code": 404,
        "type": "DoesNotExist",
        "message": "Item does not exist"
    }
}
```

Asking for `access=private` with no authentication will return a `401`,
and asking for a user you don't have access to with an `access=private`
will return a `403` (and a `404` instead if the requested user does not
exist).

##### `PUT`

A `PUT` operation requires to be authenticated as the user you will be
modifying. `PUT`ing a user with new information will modify that user's
data. Currently the only allowed operation is to set the user's
`user_id`, and it can only be done once. The reason is that new users
are created only through Persona / BrowserID: when a unknown user logs
in with Persona, the server receives his associated email address, and
sets the `user_id` of the newly created user to be that email address.
Querying such a user with `GET /users/bill@example.com?access=private`
will yield:

```json
{
    "user": {
        "user_id": "bill@example.com",
        "user_id_is_set": "false",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "exp_ids": [],
        "n_profiles": 0,
        "n_devices": 0,
        "n_results": 0,
        "persona_email": "bill@example.com"
    }
}
```

(Note the `"user_id_is_set": "false"` field.)

It is then necessary to set the user's `user_id` (to prevent other users
from easily obtaining his email address) with a `PUT
/users/bill@example.com` with the following data:

```json
{
    "user": {
        "user_id": "bill-the-researcher"
    }
}
```

Any other data included will be ignored. Possible errors (always
accompanied by explanations) are, in the following order:

* `404` if the URL-provided `user_id` does not exist
* `401` if there is no authentication
* `400` if the received data is malformed (e.g. does not have the root
  `user` object, or is bad JSON)
* `400` if there is no `user_id` (missing required field)
* `403` if you are authenticated as another user than the one you are
  `PUT`ing to, or if the `user_id` has already been set (i.e. if
  `user_id_is_set` is `true`)
* `400` again if the JSON `user_id` does not fulfill the required syntax
* `409` if the JSON `user_id` is already taken by another user

If the update is successful, the updated user is returned with a `200`
code:

```json
{
    "user": {
        "user_id": "bill-the-researcher",
        "user_id_is_set": "true",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "exp_ids": [],
        "n_profiles": 0,
        "n_devices": 0,
        "n_results": 0,
        "persona_email": "bill@example.com"
    }
}
```

This operation can only be done once because the user's `user_id` is his
unique identifier on the server, which is not allowed to change once he
has started creating resources. Other operations led by a user will be
refused if his `user_id` has not been set.

##### `DELETE`

Not implemented yet. This needs to decide what different types of
deletion we provide.

#### `/users/me`

##### `GET`

This operation requires authentication, and is used to find out which
user a client is logged in as. If you are logged in as `jane`, `GET
/users/me` will return the same as `GET /users/jane?access=private`:

```json
{
    "user": {
        "user_id": "jane",
        "user_id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "exp_ids": [
            "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
            "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
        ],
        "n_profiles": 5412,
        "n_devices": 2657,
        "n_results": 65412,
        "persona_email": "jane@example.com"
    }
}
```

If you are not logged in, a `401` error is returned.

#### `/users/`

##### `GET`

`GET /users/` returns the array of all users with only public data (even
for the one you are logged in as). So being logged in as `jane` would
still yield:

```json
{
    "users": [
        {
            "user_id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
            "exp_ids": [
                "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
                "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
            ],
            "n_profiles": 5412,
            "n_devices": 2657,
            "n_results": 65412
        },
        {
            "user_id": "bill-the-researcher",
            "user_id_is_set": "true",
            "gravatar_id": "f5cabff22532bd0025118905bdea50da",
            "exp_ids": [],
            "n_profiles": 0,
            "n_devices": 0,
            "n_results": 0
        },
        ...
    ]
}
```

If you are logged in, you can add an `access=private` argument, and the
results will be restricted to the users to which you have access,
including their private information. So if you are logged in as `jane`
and have access only to yourself, a `GET /users/?access=private` will
yield:

```json
{
    "users": [
        {
            "user_id": "jane",
            "user_id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
            "exp_ids": [
                "9f84d9bb61d1e9dec2d88a3cc37838892e8bc7596dfc6ec048d0e7d3ed03e867",
                "bfdf9067f2c35395488ffb5361742c18a924132ff5da5a2d2e89090f0fd3d5ec"
            ],
            "n_profiles": 5412,
            "n_devices": 2657,
            "n_results": 65412,
            "persona_email": "jane@example.com"
        }
    ]
}
```

In that case, if no authentication is provided a `401` is returned.


### Exps

A fully shown experiment has the following fields:

* `exp_id` (public)
* `name` (public)
* `description` (public)
* `owner_id` (public)
* `collaborator_ids` (public)
* `n_results` (public)
* `n_profiles` (public)
* `n_devices` (public)

The `exp_id` is the SHA-256 hexadecimal hash of the string obtained by
putting the `owner_id` and the `name` together, separated by a `/`. In
python:

```python
from hashlib import sha256
print sha256(owner_id + '/' + name).hexdigest()
```

This id is unique across all experiments of all users, which means the
experiment's `name` is unique across all experiments of the given user
(so different users can have experiments with the same name).

#### `/exps/<exp_id>`

##### `GET`

`GET /exps/<exp_id>` works like its `users` counterpart. E.g. `GET
/exps/3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153`
returns:

```json
{
    "exp": {
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "name": "numerical-distance",
        "description": "The numerical distance experiment, on smartphones",
        "owner_id": "jane",
        "collaborator_ids": ["sophia", "bill"],
        "n_results": 24819,
        "n_profiles": 312,
        "n_devices": 312
    }
}
```

This is the same if you are logged in as the owner, one of the
collaborators, or anybody else (or not logged in), since all the
available information is public. The `access=private` parameter is
ignored here, since all information available is public.

A `GET` on a non-existing experiment returns a `404`.

##### `PUT`

Not implemented yet.

##### `DELETE`

Not implemented yet.

#### `/exps/`

##### `GET`

`GET /exps/` returns the array of all experiments, only including public
data (which is everything, for now):

```json
{
    "exps": [
        {
            "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "name": "numerical-distance",
            "description": "The numerical distance experiment, on smartphones",
            "owner_id": "jane",
            "collaborator_ids": ["sophia", "bill"],
            "n_results": 24819,
            "n_profiles": 312,
            "n_devices": 312
        },
        {
            "exp_id": "3812bfcf957e8534a683a37ffa3d09a9db9a797317ac20edc87809711e0d47cb",
            "name": "gender-priming",
            "description": "Controversial gender priming effects",
            "owner_id": "beth",
            "collaborator_ids": ["william", "bill"],
            "n_results": 4887,
            "n_profiles": 98,
            "n_devices": 98
        },
        ...
    ]
}
```

Here again, the `access=private` parameter is ignored (only public
information is available). If no experiment matching the query is found,
an empty array is returned (instead of a `404`).

##### `POST`

`POST /exps/` creates an experiment for the currently logged in user,
and returns the completed object with its `exp_id`. Possible fields are:

* `owner_id` (required)
* `name` (required)
* `description` (optional)
* `collaborator_ids` (optional)

Any omitted optional field will be completed with an empty value, and
any forbidden or useless data will be ignored (e.g. the `n_results` or
`n_profiles` fields).

If the creation is successful, the full object is returned with a `201`
code (including the generated `id`). For instance, if we are logged in
as `jane`, a `POST /exps/` with the following data

```json
{
    "exp": {
        "owner_id": "jane",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones"
    }
}
```

will return a `201` code with the following body:

```json
{
    "exp": {
        "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
        "name": "motion-after-effect",
        "description": "After motion effects on smartphones",
        "owner_id": "jane",
        "collaborator_ids": [],
        "n_results": 0,
        "n_profiles": 0
    }
}
```

Possible errors are, in the following order:

* `401` if there is no authentication
* `400` if the `POST` body is malformed (e.g. no root `exp` object, or
  bad JSON)
* `403` if `owner_id` does not match the authenticated user
* `403` if the future owner does not have his `user_id` set
* `400` if a required field is missing
* `400` if one of the claimed collaborators does not exist or his
  `user_id` is not set
* `400` if the owner is in the collaborators
* `400` again if the `name` does not fulfill the required syntax
* `409` if the `name` is already taken by another experiment for that
  user


### Devices

A fully shown device has the following fields:

* `device_id` (public)
* `vk_pem` (public)

`vk_pem` is the device's public key in PEM format (used further down for
verification of signature on profiles and results), and the `device_id`
is the SHA-256 hexadecimal hash of that string. That id is unique across
all devices (which makes sure the public key is also unique across
devices).

#### `/devices/<device_id>`

##### `GET`

A `GET /devices/<device_id>` will return the device's public
information, and authentication is not taken into account. The `GET`
returns:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

If the device is not registered, a `404` is returned.

Authentication is not taken into account here because there is no
private data in the model, so the only information possibly worth
protecting is which keys are registered and which aren't. But hiding
that means not distinguishing between a user having access to a device
(which should give a `403`), and a device not being registered (which
should give a `404`), returning the same error for both cases. That
leads to awful twists in the API with `PUT` and `POST` methods, so it's
way simpler to have all this information public, especially since it's
not particularly sensitive.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we support.

#### `/devices/`

##### `GET`

`GET /devices/` returns the array of all registered devices. `GET
/devices/` will return something along the lines of

```json
{
    "devices": [
        {
            "device_id": "dd51a2d8a72b13f8ab395635fd51391ec2a3ee4d3bdac4aab05b5722c7c662a4",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
        },
        {
            "device_id": "e2a1698df15ea7a6b385366fa69a15ecfb3bdf24e846893be56ca9d6d4deaaea",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEYELaWxsVhIeLg1r2ASgcYA1IxTYa\nYpvi9ZnAdO/A4vm0/9u+n/fjRBCLGSgF+nmJq5yBqc6jL+aI4mseuuET7g==\n-----END PUBLIC KEY-----\n"
        },
        ...
    ]
}
```

##### `POST`

`POST /devices/` creates a device by registering its public key for
future verifying of signatures of profiles and results. You should
`POST` with data in the following format:

```json
{
    "device": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

User authentication is again not taken into account here, since this
method is intended for real devices to register themselves. Any other
data than the `vk_pem` field is ignored.

Possible errors are, in the following order:

* `400` if the data is malformed (bad JSON, or no `vk_pem` field)
* `409` if the posted key is already registered

If the registration is successful, the full device information is
returned (i.e. with the registration id) with a `201` status code:

```json
{
    "device": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEdMfIu402mP8nGmkzX0qQl7yY7i/W\nfqxgTdXo1Di/Lt7AeRKi/lVeZl0zDR153cUtMu0SreUcL97OItSGe1JYnQ==\n-----END PUBLIC KEY-----\n"
    }
}
```

The `device_id` should be recorded for further use, as it is the `id`
the device will have to present when sending a profile.


### Profiles

A profile represents information about a subject (subjects are
considered to have a one-to-one relationship with devices) collected for
the purpose of an experiment. So a profile belongs to an experiment and
optionally to a device, and the profile is the information about the
subject that is relevant to the experiment. A subject has one profile
per experiment.

This information his highly private. Retrieving is only for
authenticated users who have the profile in one of their experiments,
and modifying it can only be done with signed data from a device.

A fully shown profile has the following fields:

* `profile_id` (public)
* `vk_pem` (public)
* `exp_id` (private)
* `device_id` (optional, private)
* `n_results` (private)
* `data` (private)

`vk_pem` is the profile's public key in PEM format (used further down
for verification of signature on results), and the `profile_id` is the
SHA-256 hexadecimal hash of that string. That id is unique across all
profiles (which makes sure the public key is also unique across
profiles).

#### `/profiles/<profile_id>`

##### `GET`

`GET /profiles/<profile_id>` will return only public information
regardless of authentication, and `GET
/pprofiles/<profile_id>?access=private` will return private information
if you are logged in as a user who has that profile in one of his
experiments. In that case, not providing authentication will return a
`401`, and querying a profile you don't have access to will return a
`403`. If the requested profile doesn't exist, a `404` is returned,
before any other error. So for a user who has access to the requested
profile (it is in one of his experiments), a `GET` with `access=private`
returns something like:

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "n_results": 513,
        "data": {
            "birth_year": 1985,
            "gender": "Male",
            "occupation": "social worker"
        }
    }
}
```

The `device_id` field may or may not be present, depending on the way
the profile was registered: a profile may be attached to a device, but
this is not mandatory. This allows several experiments to have a
different profile for each experiments (but for the same subject) and
pool the trust they have in their subject between experiments (i.e. it
provides a means of identifying that profile `A` and profile `B` are in
fact the same trustworthy person, while still having separate records
for the different types of information you might want to know for each
experiment).

Without the `access=private` argument, a `GET` returns:

```json
{
    "profile": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n"
    }
}
```

##### `PUT`

`PUT`ing a profile can only be done by a profile or a device, so no user
authentication is taken into account here. We only consider signature of
data, as explained below.

There are two degrees of modification for a profile:

* Either you only change the `data` object (i.e. the real content of the
  profile), in which case the `PUT` body must be signed by the profile's
  private key. This makes sure only the creator of the profile can
  modify its data.
* Or you are also adding a `device_id` to a profile that doesn't have any.
  This means attaching an existing profile to an existing device, and
  can only be done once. When doing this, the `PUT` body must be signed
  by *both* the profile's private key and the device's private key. This
  makes sure both the creator of the profile and the creator of the
  device agree to modify this data (in practice, it's to make sure those
  two creators are in fact the same).

In both cases, signing follows version 14 of the [Draft JSON Web
Signature](http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-14)
specification, and is further detailed in the *Signing* section at the
end of the document.

Let's start with the first case. A `PUT
/profiles/d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232`
with the following signed data (signed with the profile's private key)

```json
{
    "profile": {
        "data": {
            "birth_year": 1985,
            "gender": "Male",
            "occupation": "lover"
        }
    }
}
```

will update that subject's `occupation`. Note that the whole `data` field is
replaced by the provided one. Any other fields included outside of the `data`
object will be ignored, except if it is a `device_id` (see below). Note that the
actual data sent doesn't look like that, because of the signature (again, see
the *Signing* section below for details on the signature format).

For the second case, a `PUT
/profiles/3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4`
with the following data signed by *both the profile and the device*

```json
{
    "profile": {
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c"
    }
}
```

will attach that profile to that device. Again, the actual data sent
doesn't look like that because of the signatures. You can also add a
`data` object like in the first case, and all modifications get done in
one go.

The number of signatures found on the `PUT`ed data determines which case
we are in. In both cases, possible errors are, in the following order:

* `404` if the URL-provided `profile_id` does not exist
* `400` if the received data is malformed, which can be because of:
  * malformed, missing, or too many signature(s)
  * malformed JSON or missing fields
* In the case where there are two signatures, a `400` if the `device_id`
  to be added does not exist
* In the case where there are two signatures, a `403` if there isn't
  exactly one valid from the `device_id` and one valid from the
  `profile_id`
* In the case where there is only one signature, a `403` if that
  signature is not from the provided `profile_id`
* In the case where there are two signatures, a `403` if the `device_id`
  has already been set on the target profile

In all cases, if a `profile_id` field is provided in the body of the
`PUT` it is ignored (even if not the same as the URL one). If a
`device_id` is provided but there is only one signature, it is ignored
(even if the target profile already had a different `device_id`). Finally, note
that when `PUT`ing, any provided `data` field will replace the existing one: so
`PUT`ing an empty `data` field empties the profile of its information. It works
the other way around at the above level: if a profile has a device set, `PUT`ing
information without a `device_id` will not delete the device from the profile's
information, because that tie is irreversible.

If the update is successful, a `200` status code is returned along will
the complete profile.

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we provide.

#### `/profiles/`

##### `GET`

`GET /profiles/` will return the array of all profiles, including only
public information. If you are logged in, you can add an
`access=private` argument, which will restrict results to profiles to
which you have access, and include their private information. Asking for
`access=private` and not providing authentication will return a `401`.
So if you are logged in and have only access to profile `d7e...`, a
`GET` with `access=private` will return:

```json
{
    "profiles": [
        {
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE9ewSTvXOwTxycfJtdd+AqqCrKPL8vkyQ\nnL0T8/Zx9zRxmmMDq5PgpXvFIjQcjI+17QmKcTBYebyrNVwbUCt7GA==\n-----END PUBLIC KEY-----\n",
            "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
            "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "n_results": 513,
            "data": {
                "birth_year": 1985,
                "gender": "Male",
                "occupation": "social worker"
            }
        }
    ]
}
```

If no profile is found, an empty array is returned (instead of a
`404`).

##### `POST`

Creating a profile is done with a signed `POST /profiles/`. You can
create a profile attached to an existing device, or without device.
Possible fields are:

* `vk_pem` (required)
* `exp_id` (required)
* `device_id` (optional)
* `data` (optional)

Providing a `device_id` field will only work if the corresponding device
has also signed the sent data.

For example, `POST`ing the following signed data (signed by the private
key corresponding to the claimed public key)

```json
{
    "profile": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "hydraulics engineer"
        }
    }
}
```

will create the corresponding profile without any ties to a device.
Additional unauthorized data (like a `profile_id` field) is ignored.

Now `POST`ing the same data with an additional `device_id`, signed by
*both the device and the private key corresponding to the claimed public
key*

```json
{
    "profile": {
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "device_id": "a34f1b9f6f03dafa0e6f7b8550b8acb03bfb65967ba1fe58e3d2be47acb6d13c",
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "hydraulics engineer"
        }
    }
}
```

will create the corresponding profile without tied to its device.

Here again, the number of signatures on the `POST`ed data determines
which case we're in. Possible errors are, in the following order:

* `400` if the received data is malformed, which can be because of:
  * malformed, missing, or too many signature(s)
  * malformed JSON or missing fields
* In the case where there are two signatures, a `400` if the `device_id`
  to be added does not exist
* In the case where there are two signatures, a `403` if there isn't
  exactly one valid from the `device_id` and one valid from the
  private key corresponding to the claimed public key
* In the case where there is only one signature, a `403` if that
  signature is not valid from the claimed public key
* `400` if the claimed experiment does not exist
* `409` if the claimed public key is already registered

If the registration is successful, a `201` code is returned with the
full profile body (which includes the created id):

```json
{
    "profile": {
        "profile_id": "3aebea0ed232acb7b6f7f8c35b56ecf7989128c9d5a9ea52f3fd3f2669ea39f4",
        "vk_pem": "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEK2M+PL6jQSA7hEcHIIAmZTfDBo8K05fN\nL20u6eEFHqijnCuGj6rU/y3fXGTWX9dpGEiXeHZn/2aKpz2vL16wLg==\n-----END PUBLIC KEY-----\n",
        "exp_id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
        "n_results": 0,
        "data": {
            "birth_year": 1981,
            "gender": "Female",
            "occupation": "hydraulics engineer"
        }
    }
}
```

and the additional `device_id` field in the case of registration with a
device.

The new `profile_id` should be recorded to be provided in future
communications, for instance when uploading experiment results.


### Results

A result is some information sent in by a profile (i.e. physically by a
device) that's relevant to an experiment. This information is again
highly private, and is only for users who own (or collaborate with) the
experiment for which this data is a result.

A fully shown result has the following data:

* `result_id` (public)
* `profile_id` (private)
* `exp_id` (private)
* `created_at` (private)
* `data` (private)

The `result_id` is the SHA-256 hexadecimal hash of the concatenation of
the `profile_id`, an `@` sign, the `created_at` timestamp
(`created_at` is in ISO 8601 format, i.e. `YYYY-MM-DDTHH:MM:SS.mmmmmmZ`),
a `/` sign, and the compact JSON representation of the `data` object.
In python:

```python
from hashlib import sha256
from json import dumps
print sha256(profile_id + '@' + created_at +
             '/' + dumps(data, separators=(',', ':'))).hexdigest()
```

This makes sure the `result_id` is unique in all circumstances.

#### `/results/<result_id>`

##### `GET`

`GET /results/<result_id>` will return only public information
regardless of authentication. `GET /results/<result_id>?access=private`
will return private information if you are logged in as a user owning
(or collaborating with) the target experiment for the result. In that
case, not providing authentication will return a `401`, and asking for a
result that's not in one of your experiments will return a `403`.

A `GET` without the `access=private` argument returns something like:

```json
{
    "result": {
        "result_id": "6af292d69252ccdd64718f06208485d05e9b8edd585a33dd20b54bb977c37367"
    }
}
```

A `GET` with the `access=private` argument returns something like:

```json
{
    "result": {
        "result_id": "949013edfae9758a37c16da780e29f148b5fa75cdff845b20e2f9f61dccf129e",
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
        "created_at": "2013-06-14T15:52:40.216842",
        "data": {
            "trials": [
                {
                    "real_orientation": 32,
                    "perceived_orientation": 44
                },
                ...
            ]
        }
    }
}
```

##### `DELETE`

Not implemented yet. Needs to decide what kinds of deletions we support.

#### `/results/`

##### `GET`

`GET /results/` returns the array of all results, including only public
information. If you are logged in, you can add an `access=private`
argument, which will restrict response to results that are in your
experiments, and include their private information. Asking for
`access=private` and not providing authentication will return a `401`.
So if you are logged in and have only one experiment with two results, a
`GET /results/?access=private` will return:

```json
{
    "results": [
        {
            "result_id": "949013edfae9758a37c16da780e29f148b5fa75cdff845b20e2f9f61dccf129e",
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
            "created_at": "2013-06-14T15:52:40.216842",
            "data": {
                "trials": [
                    {
                        "real_orientation": 32,
                        "perceived_orientation": 44
                    },
                    ...
                ]
            }
        },
        {
            "result_id": "2c620635b0d46cc0d03b77bda51c427dcf5e3646220559fbaec7566172528404",
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
            "created_at": "2013-06-14T15:53:52.916708",
            "data": {
                "trials": [
                    {
                        "real_orientation": 181,
                        "perceived_orientation": 207
                    },
                    ...
                ]
            }
        }
    ]
}
```

If no results are found, an empty array is returned.

##### `POST`

`POST`ing results can only be done by a profile, which means posted data
must be signed by the author profile. Possible fields in the `POST` body
are:

* `profile_id` (required)
* `exp_id` (required)
* `data` (required)

Any other data provided will be ignored.

So for instance posting the following signed data (signed by the private
key corresponding to the `device_id`'s public key)

```json
{
    "result": {
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
        "data": {
            "trials": [
                {
                    "real_orientation": 295,
                    "perceived_orientation": 271
                },
                ...
            ]
        }
    }
}
```

will create the corresponding result, and return a `201` with the
completed result information:

```json
{
    "result": {
        "result_id": "a28ced67d609e2ab92dfbc26f670fe71cc551c8c52bad4ac8d04dfa37c08bd66",
        "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
        "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
        "created_at": "2013-06-14T16:02:39.002963",
        "data": {
            "trials": [
                {
                    "real_orientation": 295,
                    "perceived_orientation": 271
                },
                ...
            ]
        }
    }
}
```

Possible errors are, in the following order:

* `400` if the received data is malformed (malformed or missing
  signature, malformed JSON after decoding the signature)
* `403` if the signature is invalid or if the claimed `profile_id` does
  not exist
* `400` if a required field is missing
* `404` if the target `exp_id` does not exist
* `403` if the claimed `profile_id` does not belong to the claimed
  `exp_id`

Results can also be sent in bulk, reducing the number of http requests
needed. Still signing the data, you can `POST` the following:

```json
{
    "results": [
        {
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
            "data": {...}
        },
        {
            "profile_id": "d7e6335a30ba480c923a1dc154f7e5176f3c39bbd8e67e4f148fb13edf4f2232",
            "exp_id": "b646639945296429f169a4b93829351a70c92f9cf52095b70a17aa6ab1e2432c",
            "data": {...}
        }
    ]
}
```

which will create both results in one go. The same errors apply. Note
that if you could theoretically post to different experiments at the
same time, you can't post from different profiles at the same time,
since the signature will not be valid; that in turn excludes posting to
different experiments at the same time, since a profile only has one
experiment. So a `403` will be returned if the `profile_id`s aren't all
the same or if the `exp_id`s aren't all the same. If the `POST` is
successful, the array of completed results is returned with a `201`
status code.


### Signing

Signing uses the JWS Json Serialization format explained in version 14
of the [Draft JSON Web
Signature](http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-14)
specification, which you might want to read if you want to understand
what's happening in the next lines. The JSON Serialization of the JWS is
explaned in [section
7.2](http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-14#section-7.2)
of the draft specification.

The server-side implementation is using
[python-ecdsa](https://github.com/warner/python-ecdsa) and
[python-jws](https://github.com/brianloveswords/python-jws) for
signature verification, so only the algorithms supported by python-jws
(excluding RSA)
and the keys supported by python-ecdsa are supported. I recommend:

* Algorithm ES256: ECDSA using P-256 curve and SHA-256 hash algorithm.
  ECDSA for the conciseness of the keys, and P-256 curve because
  anything larger takes ages to sign on a regular phone.
* Curve: NIST256p. That curve is also called secp256r1 in [Bouncy
  Castle](http://www.bouncycastle.org/) (the main crypto library for
  Android), and prime256v1 in OpenSSL (it's the same curve, named
  differently by three different standards bodies).

Those are the parameters used with the [Daydreaming
experiment](https://github.com/wehlutyk/daydreaming).

#### Examples

TODO: add reference to an example signing cycle
