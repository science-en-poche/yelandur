Yelandur API
============

Current version of the API is `v1`.

Yelandur serves its API from `domain.com/vX` where `X` is the current API
version. Anything above that (e.g. `domain.com/`) returns a `404` error.
Therefore you must prepend `/vX` to all your API calls.  This will be shown in
the first few examples below.


Version 1
---------

The API uses JSON as base format, and tries to follow the guidelines set down
by the [Ember.js REST
Adapter](http://emberjs.com/guides/models/the-rest-adapter/), i.e.:

* A dedicated top-level endpoint for each resource
* All data is encapsulated in a root object
* Any relationships to other objects are reflected as references to the `id`s
  of the linked objects
* Some resources can be transferred (in one direction or the other)
  individually or in arrays (always encapsulated in their root), and linked
  objects can be sideloaded (but only in the server -> client direction)

All this should become clearer in the examples below.


### Auth

All requests that modify data (`POST`, `PUT`, `DELETE`) require
authentication. All requests that involve experiment results or somehow
private data also require authentication.

For now only users can be authenticated (that is, researchers accessing data
generated by their experiments), but authenticating devices is in the works
(so that device users can retrieve their previously uploaded results).

Authentication is done thanks to [BrowserID /
Persona](https://login.persona.org/). The callback given to the `BrowserID`
protocol is `/auth/browserid/login` (i.e. `/v1/auth/browserid/login`) ; if
authentication is successful, a session cookie is set.

When testing manually, you can authenticate using
[Naja](https://github.com/wehlutyk/naja) (the Ajax frontend) and then make
your API requests directly in-browser.

`GET /auth/browserid/logout` (so `/v1/auth/browserid/logout` really) clears
the session cookie, i.e. logs the user out.


### Users

Users are identified by their login name. Being authenticated will give you
access to requests that modify data, and show you additional private data in
results.

#### `/users/<id>`

##### `GET`

`GET /users/<id>` (so `/v1/users/<id>`) gets public information about the user
identified by `id`. If you are authenticated as being that user, private
information (e.g. email address) is included.

So `GET /users/jane` returns

```json
{
    "user": {
        "id": "jane",
        "id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf"
    }
}
```

if you're not authenticated or if you're authenticated as someone else than
`jane` (note the root object encapsulation, mentioned in the guidelines
above).

If you're authenticated as `jane`, you'll get additional private
information (here, only the email attached to the user's Persona (i.e.
BrowserID)):

```json
{
    "user": {
        "id": "jane",
        "id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

Adding an `sl_exps=true` argument to the URL will sideload all the user's
experiments. Django-style query arguments can be added to limit the results,
but must be prefixed with `sl_exps_`. They are only taken into account if
`sl_exps=true` is provided. So
`GET /users/jane?sl_exps=true&sl_exps_results__count__gt=3000` would return

```json
{
    "user": {
        "id": "jane",
        "id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf"
    },
    "exps": [
        {
            "id": "3991cd52745e05f96baff356d82ce3fca48ee0f640422477676da645142c6153",
            "name": "numerical-distance",
            "description": "The famous numerical distance task, reproduced",
            "owner_id": "jane",
            "collaborator_ids": ["bether", "esda"],
            "n_results": 24854
        },
        {
            "id": "3e95168bbb013872e4c576d5f79190e14af523e3f94af2cf46a803c3680ffb14",
            "name": "after-motion-effect",
            "description": "After motion effects explored with smartphones",
            "owner_id": "jane",
            "collaborator_ids": ["bether", "will"],
            "n_results": 5176
        },
        {
            "id": "0fcc7f45421c84194a087dca5ffa2a820d41f8cf5371ac704b50886ec43e876f",
            "name": "gender-priming",
            "description": "Controversial gender-priming effects",
            "owner_id": "jane",
            "collaborator_ids": ["sophia", "nick"],
            "n_results": 3866
        }
    ]
}
```

if you're not authenticated as `jane` (and if those three experiments are the
only ones with more than 3000 results). If you are, the `user` object will
incorporate Jane's `persona_email` as it did above (but the experiment objects
won't change). If Jane has less than three experiments, the ones available
will be included. If she has none, an empty list will be included.

Any `GET` on a non-existing user (or deleted or disabled, if those are
implemented further down the road) will return an error with a `404` status
code:

```json
{
    "error": {
        "exception": "DoesNotExist",
        "exception_message": "User matching query does not exist.",
        "explanation": "The requested user was not found"
    }
}
```

##### `PUT`

A `PUT` operation requires to be authenticated as the user you will be
modifying. `PUT`ing a user with new information will modify that user's data.
Currently the only allowed operation is to set the user's `id`, and it can
only be done once. The reason is that new users are created only through
Persona / BrowserID: when a unknown user logs in with Persona, the server
receives his associated email address, and sets the `id` of the newly created
user to be that email address. Querying such a user with `GET
/users/bill@example.com` will yield:

```json
{
    "user": {
        "id": "bill@example.com",
        "id_is_set": "false",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

(Note the `"id_is_set": "false"` field.)

It is then necessary to set the user's `id` (to prevent other users from
easily obtaining his email address) with a `PUT /users/bill@example.com` with
the following data:

```json
{
    "user": {
        "id": "bill@example.com",
        "id_claim": "bill-the-researcher"
    }
}
```

Any other data included will be ignored. Possible errors (always accompanied
by explanations) are:

* `400` if the received data is malformed (e.g. does not have the root `user`
  object, or is bad JSON), if the `id` doesn't match the current `id`, or if
  the `id_claim` does not fulfil the required syntax
* `401` if there is no authentication
* `403` if you are authenticated as another user than `bill@example.com`, or
  if the `id` has already been set (i.e. if `id_is_set` is `true`)
* `404` if the user does not exist (before any other error)
* `409` if the `id_claim` is already taken by another user

If the update is successful, the updated user is returned with a `200` code:

```json
{
    "user": {
        "id": "bill-the-researcher",
        "id_is_set": "true",
        "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        "persona_email": "bill@example.com"
    }
}
```

This operation can only be done once because the user's `id` is his unique
identifier on the server, which is not allowed to change once he has started
creating resources. Other operations led by a user will be refused if his `id`
has not been set.

##### `DELETE`

Not implemented yet. This needs to decide what different types of deletion we
provide.

#### `/users/me`

##### `GET`

This operation requires authentication, and is used to find out which user a
client is logged in as. If you are logged in as `jane`, `GET /users/me` will
return the same as `GET /users/jane`:

```json
{
    "user": {
        "id": "jane",
        "id_is_set": "true",
        "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
        "persona_email": "jane@example.com"
    }
}
```

If you are not logged in, a `401` error is returned.

No URL options are taken into account on this endpoint.

#### `/users`

##### `GET`

`GET /users` returns the array of all users, with private data for the one
your logged in as (if you are logged in):

```json
{
    "users": [
        {
            "id": "jane",
            "id_is_set": "true",
            "gravatar_id": "9e26471d35a78862c17e467d87cddedf",
            "persona_email": "jane@example.com"
        },
        {
            "id": "bill-the-researcher",
            "id_is_set": "true",
            "gravatar_id": "f5cabff22532bd0025118905bdea50da",
        },
        ...
    ]
}
```

No sideloading arguments are taken into account, but django-style arguments
can again be added. So `GET /users?id_startswith=ja` would return users `jane`
and `jack`. If no user matching the query is found, an empty array is returned
(and not a `404`).


### Devices

#### `/devices/<id>`

##### `GET`

##### `PUT`

##### `DELETE`

#### `/devices`

##### `GET`

##### `POST`


### Exps

#### `/exps/<id>`

##### `GET`

##### `PUT`

##### `DELETE`

#### `/exps`

##### `GET`

##### `POST`


### Results

#### `/results/<id>`

##### `GET`

#### `/results`

##### `GET`

##### `POST`
